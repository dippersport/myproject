

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>{{ title }}</title>
    </head>
    <body>
        <p>{{ content }}</p>
    </body>
    </html>

----------------------------------------------------------------- 
 API KEY  acari teyin etmek ucun bu sayta gir ve acari yenile

   https://platform.openai.com/account/api-keys
-----------------------------------------------------------
  eger virtual olmursa powershelde edirsen
    PS C:\Users\user\Downloads\work> Get-ExecutionPolicy
Restricted
PS C:\Users\user\Downloads\work> Set-ExecutionPolicy RemoteSigned

   buda powersheldedi polzovatel adindan ise bu komandadi
  
     Set-ExecutionPolicy -Scope CurrentUser
-----------------------------------------------------------
    cd C:\Users\home\Desktop\Obivka
   
    python -m http.server 8000
   
    start python -m http.server 8000


    http://192.168.31.155:8000

bynun la sayti brauzerde gostermek olar
ya da ki bura gir https://app.netlify.com/sites/frabjous-blancmange-174f97/deploys/65a139a8b4a4170aec374fae   ve ordan papkani yukleyirsen 
------------------------------------------------------------------------------------
git init

git add .

git commit -m "Initial commit"

Соединяем локальный и удалённый репозитории
git remote add origin https://github.com/username/myproject.git

Пересылаем код в удалённый репозиторий
git push -u origin master
--------------------------------------------------------

  👨‍💻 Шпаргалка по TensorFlow

TensorFlow — библиотека для машинного обучения, которая позволяет обучать искусственный интеллект решению разных задач. 
Библиотека изначально разработана для Python и чаще всего используется с ним.

---------------------------
def oi_mate():
  print('Oi Mate!')

for i in range(10):
  oi_mate()
---------------------------------------------------------------------------------------------------------------------------
       <thead>
        <td>Name</td>
        <td>Feet</td>
        <td>Wings</td>
        </thead>
--------------------------------------------------------
textarea rows="7" cols="40">No complaints!</textarea>
-----------------------------------------------------------
           <select name="rendor-option">
<option value="door1">Door1</option>
<option value="door2">Door2</option>
<option value="door3">Door3</option>
</select>
------------------------------------------------------------------------------------------------------------------------
            <link rel="stylesheet"  type="text/css"  href="style.css">
-----------------------------------------------------------------------------------------------------------------
       	font-weight: bold;
        font-family: 'Courier';
        text-transform: uppercase;
        letter-spacing: 4px;
----------------------------------------------------------------------------------------
      <input type="password" id="pw" name="pw">
   <label for="pw">Password</label>
________________________________________________________________________________________________________________________________________-
   
def sum67(nums):
  end = True
  num = 0
  for i in range(0, len(nums), 1):
    if nums[i]==6:
      end = False
    elif end == False and nums[i] == 7:
      end = True
    elif end == True:
      num += nums[i]
  return num
________________________________________________________________________________________________________________________________________________
                              
def has22(nums):
  for i in range(0, len(nums)-1, 1):
    if nums[i] == 2 and nums[i+1] == 2:
     return True
  return False
________________________________________________________________________________________________________________________________________________-
def centered_average(nums):
  return (sum(nums) - max(nums) - min(nums)) / (len(nums) - 2) 
_________________________________________________________________________________________________________________________________________________
                                                   reverse
def reverse3(nums):
  end = 0 
  if len(nums) % 2 == 0:
    for i in range(int(len(nums)/2)):
      end = nums[i]
      nums[i] = nums[len(nums)-1-i]
      nums[len(nums)-1-i] = end
  else:
      for i in range(int((len(nums)-1)/2)):
        end = nums[i]
        nums[i] = nums[len(nums)-1-i]
        nums[len(nums)-1-i] = end
  return nums
_______________________________________________________________________________________________________________________________________________---
          
Verilmiş massivdəki cüt intlərin sayını qaytarın. Qeyd: % "mod" operatoru qalanı hesablayır, məsələn, 5 % 2 1-dir.

def count_evens(nums):
  end = []
  for n in nums:
    if n%2 == 0:
      end.append(n)
  return len(end)
_____________________________________________________________________________________________________________________________________
 
              Boş massiv üçün 0 qaytararaq massivdəki ədədlərin cəmini qaytarın. Bundan başqa 13 rəqəmi çox şanssızdır,
              ona görə də sayılmaz və 13-dən dərhal sonra gələn nömrələr də sayılmır.         


def sum13(nums):
  end = 0
  num = 0
  while num < len(nums):
    if nums[num] == 13:
      num += 1
    else:
      end += nums[num]
    num += 1
  return end
_________________________________________________________________________________________________________________________________________

import datetime

time_string = "08/01/2011"

time_stamp = datetime.datetime.strptime(time_string, "%d/%m/%Y").timestamp()

print(time_stamp) 
________________________________________________________________________________
          
                   6 ilə başlayan və növbəti 7-yə qədər uzanan nömrələrin bölmələrinə məhəl qoymamaq
                   istisna olmaqla, massivdəki nömrələrin cəmini qaytarın (hər 6-dan sonra ən azı bir 7
                   olacaq). Rəqəmlərin olmaması üçün 0 qaytarın.
def sum67(nums):
  end = True
  sum = 0
  for n in nums:
    if n == 6:
      end = False
    elif end:
      sum += n
    elif not end and n == 7:
      end = True
  return sum
_________________________________________________________________________________________________________________________________________--
                        tuzlara aiddi
 aces = [
  'Ace of Spades',
  'Ace of Diamonds',
  'Ace of Hearts', 
  'Ace of Clubs'
]

for ace in aces:
  deck_of_cards.pop(ace)
___________________________________________________________________________________________________________________________________________
   p.highlight {
       background-color: yellow; }
___________________________________________________________________________________________________________________________

      <a href="https://en.wikipedia.org/wiki/Cindy_Sherman" target="_blank">        </a>           
__________________________________________________________________________________________________________________________________________
             !-- Third paragraph: -->
               <p class="red square">I am red and in a square!</p>
_____________________________________________________________________________________________________________________________________
       
             <textarea rows="7" cols="40"> No complaints!</textarea>
____________________________________________________________________________________________________________________________
 
              <link href="style.css" rel="stylesheet"/>
_________________________________________________________________________________________________________________________________________________  
    <select name="rendom-option">
     <option value="door1">Door 1</option>
    <option value="door2">Door 2</option>
      <option value="door3">Door 3</option>
      </select>
____________________________________________________________________________________________________________________________________    
Дан массив Arr[]  из N целых чисел. Найдите непрерывный подмассив (содержащий хотя бы одно число), 
    который имеет максимальную сумму, и верните его сумму.      

     def maxSubArraySum(self,arr,N):
       
        for i in range(1, len(arr)):
            if arr[i-1] >= 0:
                arr[i] += arr[i-1]
        return max(arr)   

_____________________________________________________________________________________________________________________________
  
   <input type="password" id="pw" name="pw">
   <label for="pw">Password</label>   
-
-------------------------------------------------------------------------------------------------------------------------------
  
  void brew_tea(std::string tea_type) {
  std::cout << "Brewing" + tea_type + "tea";
}
________________________________________________________________________________________________________________________    
const changeOfScenery = () => {
  location = "A sunny park";
};
___________________________________________________________________________________________________________________________                                                                                   | 
 my_sentence = "My gosh, what a beautiful Monday morning this is."                        
                                                                                     
def m_word_count(sentence):                                                          
  count = 0
  words = sentence.split()
  for word in words:
    if word[0].lower()== 'm':
      count += 1
  return count
print(m_word_count(my_sentence))

____________________________________________________________________________________________________________________________________________-
       vowels = ["a", "e", "i", "o", "u"]


def vowel_counter(s):
  count = 0
  for letter in s:
    if letter in vowels:
      count += 1
  return count
print(vowel_counter("hello"))
___________________________________________________________________________________________________________________________________-----
    var myString = "";
var garden = {season: "spring", weather: "rainy", flowers: "blooming"};
 
for (var key in garden) {
  myString += garden[key] + " ";
}
 
console.log(myString);

// expected output: "spring rainy blooming"
____________________________________________________________
 
 const creature = 'Golem';
console.log(`A wild ${creature} appeared!`)

____________________________________________________________

   let location = "A dingy basement";

const changeOfScenery = () => {
  location= "sinny park"
};
_____________________________________________________--
const loopThroughAnimals = (pets) => {
  for (const petName in pets) {
    console.log(`${petName} : ${pets[petName].species}`)
  }
} 
-----------------------------------------------------------------------------------------------------------------------------------------------_
   function order(scoops, flavor) {
  return `Lemme get ${scoops} scoop${scoops > 1 ? 's' : ''} of ${flavor}!`
}

// Logs "Lemme get 1 scoop of vanilla!"
console.log(order(1, 'vanilla'));
// Logs "Lemme get 3 scoops of chocolate!"
console.log(order(3, 'chocolate'));
__________________________________________________________________________________________________________________________________________
  const icanhaz = (arg='cheezburger') => {
  return `i can haz ${arg}?`
}

console.log(icanhaz('presentz'));
 
console.log(icanhaz());
---------------------------------------------------------------------------------------------------------------------
   for(let i = 0; i <= 10; i+=2) {
  console.log(i)
}
------------------------------------------------------------------------------------------------------------------------------------
    def __init__(self, flavor):
       self.flavor = flavor;
___________________________________________________________

  const loopThroughAnimals = (pets) => {
  for (const petName in pets) {
    console.log(`${petName} : ${pets[petName].species}`)
  }
} 
______________________________________________________________----
        
const studentMaker = (name, GPA) => {
  return {
    name: name,
    GPA: GPA,
    calculateHonors() {
      if (GPA < 3.5) {
        return 'no honors';
      }
      if (GPA < 3.8) {
        return 'cum laude';
      }
      if (GPA < 4.0) {
        return 'magna cum laude';
      }
      return 'summa cum laude';
    }
  }
}

_________________________________________________________________________________________________________________________________
     if (temperature === "cold") {
  console.log("Bundle up!");
} else if (temperature === 'warm') {
  console.log("Warm weather...");
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 
for(let i = 0; i < titles.length; i++) {
  console.log(`${i+1}. ${titles[i]}`)
}
------------------------------------------------------------------------------------------------------------------------------------------------------
    const  workOfArt = {
       artist: 'Jon',
       material: 'cold',
       year: 2021,
       admireArt: () => {
       console.log('Oh, wonderful. Such complexity.')
   }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
        ora  elave olacag    minlength="3" required>
------------------------------------------------------------------------------------------------------------------------------
    return render(request, 'submit_success.html')     
--------------------------------------------------------------------------------------------------------------------------
       from Schedule.models import Classroom
----------------------------------------------------------------------------------------------------------------------------------------------------------
       def index(request):
         return HttpResponse("Welcome to the world’s smallest park!")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
def date_extractor(date):
  date_split = date.split('/')
  month = date_split[0]
  day = date_split[1]
  year = date_split[2]
  return month, day, year
print(date_extractor('6/16/2006'))
------------------------------------------------------------
from important_data import data_list

aggregated_sum = 0
count_data = 0

for number in data_list:
  if number.omit == True:
    # Update this line so that
    # We omit this number
    number.omit = 0
  else:
      aggregated_sum += number
      count_data += 1

------------------------------------------------------------     def __init__(self, flavor):
        self.flavor = flavor

-----------------------------------------------------------
  def append_sum(my_list):
  my_list.append(my_list[-1]+my_list[-2])
  my_list.append(my_list[-1]+my_list[-2])
  my_list.append(my_list[-1]+my_list[-2])
  return my_list
------------------------------------------------------------
if weight > 70:
  fee=100
elif weight >= 50 and weight <= 70:
  fee = 50
else:
  fee = 0
-------------------------------------------------------------------
def gregs_e_tagger(string):
  middle_index = len(string) // 2
  left = string[:middle_index]
  right = string[middle_index:]
  
  result = left + 'greg' + right
  return result

print(gregs_e_tagger('Hello World!'))
---------------------------------------------------------------------------------------------------------------------------
import datetime

time_string = "08/01/2011"

time_stamp = datetime.datetime.strptime(time_string, "%d/%m/%Y").timestamp()

print(time_stamp)
-------------------------------------------------------------------------------------------------------------------------------- 
  {% extends "base.html" %}
   {% block content %}
   <h2>I am a Heading!</h2>
   {% endblock %}
----------------------------------------------------------------------------------------------------------------------
<!DOCTYPE html>
<head>
{% block head %}
{% endblock %}
</head>
-------------------------------------------------------------------------------------------------------------------
     {{ patients|dictsort: "birthday"}}
------------------------------------------------------------------------------------------------------------------------------------------
  {% for athlete in athlete_list %}
    <li> {{ athlete.name }} </li>
{% endfor %} 
----------------------------------------------------------------------------------------------------------------------------------------
    new_instance = Teacher(first_name = "Mary", last_name = "Smith")
    new_instance.save()
------------------------------------------------------------------------------------------------------------------------------------------
    python3 manage.py runserver
    python3 manage.py migrate
-------------------------------------------------------------------------------------------------------------------------------------------
         <a href = "{% url 'checkout' username %}">Go To Checkout </a>
--------------------------------------------------------------------------------------------------------------------------------------------
   all_teachers = Teacher.objects.all() 
-----------------------------------------------------------------------------------------------------------------------------------------
    <a href="{% url 'contactus' %}">Contact Us</a>
-----------------------------------------------------------------------------------------------------------------------------------------------
            python3 manage.py startapp checkout
--------------------------------------------------------------------------------------------------------------------------------------------
    django-admin startproject djangogo
--------------------------------------------------------------------------------------------------------------------------------------------
    class Customer(models.Model):
       username = models.CharField(max_length=35, primary_key=True)
-------------------------------------------------------------------------------------------
class Animal(models.Model):
  ANIMAL_TYPES = [
     ("D", "Dog"),
     ("C", "Cat"),
     ("R", "Rabbit"),
     ("B", "Bird")]
  a_type = models.CharField(max_length=1, choices=ANIMAL_TYPES)

----------------------------------------------------------------------------------------------------------------------------------------------
     urlpatterns = [
        path('profile/<str:username>', profile_view),
     ] 
------------------------------------------------------------------------------------------------------
  def homepage(request):
  return HttpResponse("Welcome to the Zoo!")
----------------------------------------------------------------------------------------------------------------------------------------------
         {{ patients|dictsort:"birthday" }}
-------------------------------------------------------------------------------------------------------------------------------------------------
         <p>{{ birthday|date }}</p>
------------------------------------------------------------------
    Pet.objects.filter(owner=owner_instance)
-----------------------------------------------------------------------------------------------------------------------------------------------
-       teacher_instance.student_set.all()
-----------------------------------------------------------------------------------------------------------------------------------------------
     from Schedule.models import Classroom
---------------------------------------------------------------------------------------------------------------------------------------------------
    def home_view(request):
      return render(request, "index.html", context)
-------------------------------------------------------------------------------------------------------------------------------------------------
      urlpatterns = [
  path("", views.help)  
]
-------------------------------------------------------------------------------------------------------------------
   urlpatterns = [
  path("", views.home)  
]
---------------------------------------------------------------------------------------------------------------------------------
    class Meta:
     ordering = ["last_name"]
-------------------------------------------------------------------------------------------------------------------------------------
      class Meta:
        verbose_name = "professional athlete"
-----------------------------------------------------------------------------------------------------------------------------------------
       python3 manage.py startapp checkout
-------------------------------------------------------------------------------------------------
      python3 manage.py shell
      exit()
-------------------------------------------------------------------------
     exit_keys = 'ctrl + c'
     print(exit_keys)
-------------------------------------------------------------------------------------------------------------------------------------------
         python3 manage.py makemigrations
         python3 manage.py migrate
----------------------------------------------------------------------------------------------------------------------------------------
    pyton3 manage.py migrate gradebook 002
----------------------------------------------------------------------------------------------------------------------------------------------
from django.db import models
 
class Baby(models.Model):
  name = models.CharField(max_length=20)
  weight = models.IntegerField()
  birthdate = models.DateField()
--------------------------------------------------------------------------------------------------------------------
 class Student(models.Model):
  last_name = models.CharField(max_length=25)
  age = models.IntegerField()
  teacher = models.ForeignKey(Gardener, on_delete=models.CASCADE) 
--------------------------------------------------------------------------------------------------------------------------------
  class Application(forms.Form):
   first_name = forms.CharField()
   last_name = forms.CharField()
   phone = forms.IntegerField()
   email = forms.EmailField()
------------------------------------------------------------------------------------------------
from .models import Teacher
 
def school(request):
  if request.method == "POST":
    test_model = Teacher()
    test_model.field = request.POST["field_name"]
    test_model.save()
  return render(request, "template.html")
  return render(request, "template_with_form.html")
-------------------------------------------------------
#n = input("Введите трехзначное число: ")
#n = int(n)
 
n1 = n // 100 # Нахождение первой цифры числа
n2 = (n % 100) // 10 # Нахождение второй цифры числа
n3 = n % 10 # Нахождение третьей цифры числа
res = n1 + n2 + n3
 
print("Сумма цифр числа:", res)
-----------------------------------------------------------
  print(f"{int(n / 6)} {int(n / 6 * 4)} {int(n / 6)}")
------------------------------------------------------------
#n = 385916

# Введите ваше решение ниже
#n = int(input())
a = n // 100000 + n % 100000 //10000 + n % 10000 // 1000
b = n % 1000 // 100 + n % 100 // 10 + n % 10
if a == b:
    print('yes')
else:
    print('no')
--------------------------------------------------------
__________________________________________________________________________________________________________________________________________________-
___________________________________________________________________________________________________________________________________________________-
def remove_n_nodes(doubly_linked_list, n):
  # while n is greater than 0
  while n > 0:
    doubly_linked_list.remove_head()
     n = n - 1
  
from help import test_your_code

test_your_code(remove_n_nodes)
---------------------------------------------------------------------------------------------------------------------------------------------------------
def recurse(n):
  recurse.count+=1
  recurse.call_stack.append(n)

  if n <= 1:
    return
  if n % 2 == 0:
    return recurse(n-3)
  else:
    return recurse(n+1)


-------------------------------------------------------------------------------------------------------------------------------------------------------------
def is_in_tree(bst,nums):
  # initialize result list
  result_lst = []

  # for every number in nums list
  for num in nums:
    # search for number in bst
    node = bst.get_node_by_value(num)
    # if node is not None add to result
    if node is not None:
      result_lst.append(node)
  # return result
  return result_lst

_______________________________________________________________________________________________________________________________________________________-

from DoublyLinkedList import DoublyLinkedList

class ExtendedDoublyLinkedList(DoublyLinkedList):
  def __init__(self):
    super().__init__()

  def remove_all_by_value(self, value):
    while True:
      returned_node = self.remove_by_value(value)
      if returned_node is None:
        break
from help import test_your_code

test_your_code(ExtendedDoublyLinkedList)
____________________________________________________________
from Node import Node
from help import test_your_code

class DoublyLinkedList:
  def __init__(self, value):
     
    new_node = Node(value)

    self.head_node = new_node
    self.tail_node = new_node
    
test_your_code(DoublyLinkedList)
_______________________________________________________________________________________________
       
  def add_n_strings_to_tail(doubly_linked_list, n):     eger tali yerine head olarsa onda
  # loop n times to repeatedly call doubly_linked_list.add_to_tail()
   while  n > 0:
    # add to tail
    doubly_linked_list.add_to_tail("f")     burda tail yerine head yaz 
    
    n = n - 1
_______________________________________________________________________________________________________________________________________________________________
     from DoublyLinkedList import *

def reverse_dll(input_dll):
..
  
  
  result_dll = DoublyLinkedList()

  while True:
    tail_value = input_dll.remove_tail()
    if tail_value is None:
      break
    result_dll.add_to_tail(tail_value)
  return result_dll
# Test your function
from help import test_your_code

test_your_code(reverse_dll)   
____________________________________________________________________________________________________________________________________________________________
 
 from models.DoublyLinkedList import DoublyLinkedList
from util.help import test_your_code

def make_dll(doubly_linked_list, random_value):
  # step 1
  dll = DoublyLinkedList()

  # step 2
  head_value = doubly_linked_list.remove_head()

  # step 3
  tail_value = doubly_linked_list.remove_tail()

  # step 4
  dll.add_to_head(head_value)

  # step 5
  dll.add_to_tail(tail_value)

  # step 6
  dll.add_to_head(random_value)

  # step 7
  return dll

test_your_code(make_dll)
______________________________________________________________________________________________________________________________________________

from help import BinarySearchTree, print_bst, gen_size3_bst

def sum_bst_size3(bst):
  bst_sum = 0

  bst_sum = bst.value + bst.left.value + bst.right.value

  return BinarySearchTree(bst_sum)
  
bst = gen_size3_bst()
_______________________________________________________________________________________________________________________________________________________________
from help import BinarySearchTree, print_tree, gen_list

def list_to_bst(nums):
 
  # define your bst with the first element of nums as root
  bst = BinarySearchTree(nums[0])

  # insert elements into bst starting from index 1 of nums
  for number in nums[1:]:
    bst.insert(number)
  # return your bst
  return bst


# Uncomment below to test your function

# get test list
test_list = gen_list()
______________________________________________________________________________________________________________________________________________________________
def pre_order_to_list(bst, nums):
  if bst is None:
    return 
  nums.append(bst.value)
  pre_order_to_list(bst.left, nums)
  pre_order_to_list(bst.right, nums)
_____________________________________________________________________________________________________________________
 memo = {}

def fibonacci(num):
  answer = None
  # Write your code here
  if num in memo:
    answer = memo[num]
  elif num == 0 or num == 1:
    answer = num
  else:
    answer = fibonacci(num-1) + fibonacci(num-2)
    memo[num] = answer
  return answer

# Test your code with calls here:
print(fibonacci(20))
print(fibonacci(200
______________________________________________________________________________________________________________________________________________________________
   Завершите функцию так, чтобы left_node их right_nodes next_node и prev_nodes были правильно связаны друг с другом.  
  class Node:
  def __init__(self, value = None, next_node=None, prev_node=None):

    self.value = value
------
------  axirda bunlari yaz

  left_node.set_next_node(right_node)

  right_node.set_prev_node(left_node)
----------------------------------------------------------------------------------------------
______________________________________________________________________________________________________________________________________________________________
------------------------------------------------------------------------------------------------------------------------------------------------- 
            Уточнить проблему
    1 Создать входы
    2 Обрисуйте решение
    3 Закодируйте решение
    4 Протестируйте решение
    5 Проанализируйте решение
-----------------------------------------------------------------------------------------------------------------------------------------------
                                                                      СВЯЗАННЫЕ СПИСКИ: PYTHON
class Node:
  def __init__(self, value, next_node=None):
    self.value = value
    self.next_node = next_node
    
  def get_value(self):
    return self.value
  
  def get_next_node(self):
    return self.next_node
  
  def set_next_node(self, next_node):
    self.next_node = next_node

class LinkedList:
  def __init__(self, value=None):
    self.head_node = Node(value)
   
  
  def get_head_node(self):
    return self.head_node
  
  def insert_beginning(self, new_value):
    new_node = Node(new_value)
    new_node.set_next_node(self.head_node)
    self.head_node = new_node
    
  def stringify_list(self, sil):
    string_list = ""
    current_node = self.get_head_node()
    while current_node:
      if current_node.get_value() != None:
        string_list += str(current_node.get_value()) + "\n"
      current_node = current_node.get_next_node()
    return string_list
  
  def remove_node(self, sil, value_to_remove):
    current_node = self.get_head_node()
    if current_node.get_value() == sil:
      self.head_node = current_node.get_next_node()
    else:
      while current_node:
        next_node = current_node.get_next_node()
        if next_node.get_value() ==   sil:
          current_node.set_next_node(next_node.get_next_node())
          current_node = None
        else:
          current_node = next_node
ll = LinkedList(5)
ll.insert_beginning(70)
ll.insert_beginning(5675)
ll.insert_beginning(90)
print(ll.stringify_list(96))
-----------------------------------------------------------------------------------------------------
def merge_sort(nums):
    if len(nums) > 1:
        mid = len(nums) // 2
        left = nums[:mid]
        right = nums[mid:]
        merge_sort(left)
        merge_sort(right)
        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                nums[k]= left[i]
                i+= 1

            else:
                nums[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            nums[k] = left[i]
            i+=1
            k+=1
        while j < len(right):
            nums[k] = right[j]
            j+=1
            k+=1

list1 = [1,3,5,3,8,23,45,2]
merge_sort(list1)
print(list1)
-----------------------------------------------------------------------------------------------------------------------------------------------
                                                                ДВУСВЯЗНЫЕ СПИСКИ: PYTHON

Добавить новый узел в голову (начало) списка
Добавить новый узел в хвост (конец) списка
Удалить узел из головы списка
Удалить узел из хвоста списка
Найти и удалить конкретный узел по его значению
Распечатайте узлы в списке по порядку от головы к хвосту




class Node:
  def __init__(self, value, next_node=None, prev_node=None):
    self.value = value
    self.next_node = next_node
    self.prev_node = prev_node
    
  def set_next_node(self, next_node):
    self.next_node = next_node
    
  def get_next_node(self):
    return self.next_node

  def set_prev_node(self, prev_node):
    self.prev_node = prev_node
    
  def get_prev_node(self):
    return self.prev_node
  
  def get_value(self):
    return self.value


class DoublyLinkedList:                                              Начните с проверки, есть ли текущая глава в списке.
  def __init__(self):                                                Если есть (имеется в виду, что список не пустой), то мы
    self.head_node = None
    self.tail_node = None                                            хотим сбросить указатели в начале списка:
                                                                     Установить предыдущий узел текущей головы на новую голову
  def add_to_head(self, new_value):                                  Установить следующий узел новой головы на текущую голову
    new_head = Node(new_value)                                       Обновите свойство head, чтобы оно стало новым head
    current_head = self.head_node                                    Наконец, если в списке нет текущего хвоста (это означает, что список был пуст):
                                                                     new_head Node, который принимает new_value в качестве параметра

    if current_head != None:                                         current_head Node, который установлен в начале списка
      current_head.set_prev_node(new_head)                           Если в списке есть текущая глава:
      new_head.set_next_node(current_head)                           Установите current_head предыдущий узел в new_head
                                                                     Установите new_head следующий узел в current_head
                                                                      использовать Node классы .set_prev_node() и .set_next_node() методы.
    self.head_node = new_head
                                                                      Обновите свойство tail, чтобы оно стало новой головкой, так как                                          
    if self.tail_node == None:                                        этот узел будет и головой, и хвостом списка.
      self.tail_node = new_head                                       если у списка нет хвоста , установите хвост списка в новую голову.


  def add_to_tail(self, new_value):                                   current_tail Node, установленный в конец списка
    new_tail = Node(new_value)                                        Если в списке есть текущий хвост:
    current_tail = self.tail_node                                     Установите следующий узел текущего хвоста в new_tail
                                                                      Установить new_tail предыдущий узел в текущий хвост
    if current_tail != None:
      current_tail.set_next_node(new_tail)
      new_tail.set_prev_node(current_tail)

    self.tail_node = new_tail                      

    if self.head_node == None:
      self.head_node = new_tail                                       если у списка нет заголовка , установите заголовок списка на новый хвост.

  def remove_head(self):                                               Снятие головы
    removed_head = self.head_node                                     Начните с проверки, есть ли текущая глава в списке.
                                                                      Если нет, то список пуст, поэтому удалять нечего и метод завершается.
    if removed_head == None:                                          В противном случае обновите заголовок списка, чтобы он стал следующим узлом текущего заголовка.

      return None                                                     removed_head переменную и установите ее в головной узел списка.

                                                                      Если обновленного заголовка нет None(это означает,что в начале списка было более одного элемента):
                                                                      Установите предыдущий узел заголовка, None так как перед началом списка не должно быть узла.
                                                                      Если удаленная голова также была хвостом списка ( что в списке был только один элемент):
                                                                      Вызов .remove_tail(),чтобы внести необходимые изменения в конец списка(это в следующем упражнении!)
                                                                      Наконец, верните значение удаленной головы

    self.head_node = removed_head.get_next_node()

    if self.head_node != None:
      self.head_node.set_prev_node(None)

    if removed_head == self.tail_node:
      self.remove_tail()

    return removed_head.get_value()
                                                                      Удаление хвоста
  def remove_tail(self):                                              Начните с проверки, есть ли текущий конец списка.
    removed_tail = self.tail_node                                 

    if removed_tail == None:                                          Если нет, список пуст, поэтому удалять нечего, и метод завершается.
      return None
                                                                      В противном случае обновите хвост списка, чтобы он был предыдущим узлом текущего хвоста.
    self.tail_node = removed_tail.get_prev_node()                     Если обновленный хвост не является None
                                                                      Установите следующий узел хвоста, None так как после хвоста списка не должно быть узла.
    if self.tail_node != None:                                        Если удаленный хвост был также головой списка (это означает, что в списке был только один элемент):
      self.tail_node.set_next_node(None)

    if removed_tail == self.head_node:                               Звонок .remove_head()для внесения необходимых изменений в шапку списка
      self.remove_head()                                             Наконец, верните данные старого хвоста
                                                                     Проверьте, removed_tail равен ли заголовок списка. Если это так, вызовите .remove_head()метод.
    return removed_tail.get_value()


                                                                    remove_by_value()метод, который позволит вам вычеркивать (удалять
                                                                     это поручение независимо от того, где оно находится в списке.
                                                                     Итерация по списку, чтобы найти соответствующий узел
                                                                     Если в списке нет подходящего элемента:
                                                                     ВозвращатьсяNone
                                                                     Если есть соответствующий узел, мы затем проверим, является ли он началом или хвостом списка:
                                                                     Если это так, вызовите соответствующий .remove_head()или .remove_tail()метод
                                                                     Если нет, значит узел был где-то в середине списка. В таком случае:
                                                                     Удалите его, сбросив указатели его предыдущего и следующего узлов.
                                                                     Наконец, верните свойство value узла

  def remove_by_value(self, value_to_remove):                        
    node_to_remove = None                                           
    current_node = self.head_node

    while current_node != None:
      if current_node.get_value() == value_to_remove:               Внутри цикла обновите его, current_node чтобы он стал его следующим узлом.
        node_to_remove = current_node                               if проверяет, совпадает ли current_node's value с переданным value_to_remove
        break                                                       это означает, что мы нашли соответствующий узел.

      current_node = current_node.get_next_node()

    if node_to_remove == None:
      return None                                                  списке не было подходящего узла, поэтому вернитесь, None чтобы завершить метод.

    if node_to_remove == self.head_node:                                      Удаление по значению II
      self.remove_head()                                            Узел был во главе списка, и в этом случае мы можем просто вызвать.remove_head()
    elif node_to_remove == self.tail_node:                          Узел был хвостом списка, и в этом случае мы можем просто вызвать.remove_tail()
      self.remove_tail()                                            Узел был где-то в середине списка, и в этом случае нам нужно будет вручную изменить
    else:                                                           указатели на его предыдущий и следующий узлы
      next_node = node_to_remove.get_next_node()                    else блоке создайте:
                                                                    Узел next_node, равный node_to_remove следующему узлу
      prev_node = node_to_remove.get_prev_node()                    Узел prev_node, который равен node_to_remove предыдущему узлу
      next_node.set_prev_node(prev_node)                            когда у нас есть наши узлы, мы можем удалить указатели на и из,
      prev_node.set_next_node(next_node)                            node_to_remove а также иметь next_node и prev_node указывать друг на друга
                                                                    Установите next_node предыдущий узел в prev_node
    return node_to_remove                                           Установите prev_node следующий узел в next_node

  def stringify_list(self):
    string_list = ""
    current_node = self.head_node
    while current_node:
      if current_node.get_value() != None:
        string_list += str(current_node.get_value()) + "\n"
      current_node = current_node.get_next_node()
    return string_list
subway = DoublyLinkedList()
subway.add_to_head("Times Square")
subway.add_to_head("Grand Central")
subway.add_to_head("Central Park")
print(subway.stringify_list())

--------------------------------------------------------------------------------------------------------------------------------------------------
                                                               Два указателя движутся параллельно
def nth_last_node(linked_list, n):
  current = None
  tail_seeker = linked_list.head_node
  count = 1
  while tail_seeker:
    tail_seeker = tail_seeker.get_next_node()
    count += 1
    if count >= n + 1:
      if current is None:
        current = linked_list.head_node
      else:
        current = current.get_next_node()
  return current
                                                              Указатели на разных скоростях
 
                                                       find_middle()функцию и средний узел linked_list.
from LinkedList import LinkedList

# Complete this function:
def find_middle(linked_list):
  fast = linked_list.head_node
  slow = linked_list.head_node
  while fast:
    fast = fast.get_next_node()
    if fast:
      fast = fast.get_next_node()
      slow = slow.get_next_node()
  return slow
--------------------------------------------
def generate_test_linked_list(n):
  linked_list = LinkedList()
  for i in range(20, 0, -1):
    linked_list.insert_beginning(i)
  return linked_list
                                                           <------------------------ bu test
# Use this to test your code:
test_list = generate_test_linked_list(9)
print(test_list.stringify_list())
middle_node = find_middle(test_list)
print(middle_node.value)
----------------------------------------------------------------------------------------------------------------------------------------------------
                                                                    ЛИНЕЙНЫЙ ПОИСК: PYTHON

recipe = ["nori", "tuna", "soy sauce", "sushi rice"]
target_ingredient = "avocado"

def linear_search(my_list, target_value):
  seen = []
  for i in range(len(my_list)):
    if my_list[i] == target_value:
      seen.append(i)
    if seen:
      return seen
    else:
      return recipe[2]


print(linear_search(recipe, target_ingredient))
--------------------------------------------------------------------------------------------------------------------------------------------------
                                                              ОЧЕРЕДИ: PYTHON
Очереди предоставляют метода взаимодействия:

Очереди:

Содержат узлы данных
Поддержка трех основных операций:
Enqueue добавляет данные в конец очереди
Dequeue удаляет и предоставляет данные из начала очереди
Peek предоставляет данные в начале очереди
Может быть реализован с использованием связанного списка или массива
Ограниченные очереди имеют ограниченный размер.
Постановка в полную очередь приводит к переполнению очереди
Очереди обрабатывают данные «первым пришел, первым обслужен» (FIFO).

from node import Node
                                                                     создавать ограниченные очереди с max_size предотвращает «переполнение» и 
class Queue:                                                                   «недостаточное количество» очереди

                                                                 Свойство size для отслеживания текущего размера очереди
                                                                    Свойство max_size, которое ограниченные очереди могут и
  def __init__(self, max_size=None):                                  спользовать для ограничения общего количества узлов.
    self.head = None
    self.tail = None                                                
    self.max_size = max_size
    self.size = 0                                                                get_size()вернет значение size свойства
    
  def enqueue(self, value):                                                   has_space()вернется True, если в очереди есть место для другого узла
    if self.has_space():
      item_to_add = Node(value)                                               is_empty() вернет true, если size 0
      print("Adding " + str(item_to_add.get_value()) + " to the queue!")      Выведите «Добавление « + str(item_to_add.get_value())+» в очередь!»
      if self.is_empty():                                                       метод enqueue(), который принимает значение узла valueв качестве параметра.
        self.head = item_to_add
        self.tail = item_to_add                                                 ifпредложение, чтобы проверить, есть ли в очереди место
      else:
        self.tail.set_next_node(item_to_add)                                Если это так, создайте экземпляр a Node, который принимает valueв качестве аргумента, 
                                                                              и назначьте его новой переменной.item_to_add
        self.tail = item_to_add                                         Проверьте, не пуста ли очередь — если да, установите как экземпляр, так headиtailitem_to_add
      self.size += 1                                                  установить item_to_add как текущий tailследующий узел
    else:                                                              установить tailравнымitem_to_add   
      print("Sorry, no more room!")                                         Увеличить очередь size на 1
                                                              else оператор. Внутри него распечатайте «Извините, места больше нет!»
  def dequeue(self):
    if self.get_size() > 0:                                          Как и в случае с peek(), наш dequeue()метод должен возвращать значение head. В отличие от , 
      item_to_remove = self.head                                       peek()также dequeue()удалит текущий узел headи заменит его следующим узлом.
      print(str(item_to_remove.get_value()) + " is served!")                  if nредложение пуста ли очередь Если это так item_to_remove установите в текущую head
      if self.get_size() == 1:                                          напечатайте:«Удаление « + str(item_to_remove.get_value())+» из очереди!»
        self.head = None
        self.tail = None                                              sonra yoxla size 1 beraberdimi eger he onda укажите очереди head,  tail olacag None
      else:                                                            уменьшить очередь size на 1
        self.head = self.head.get_next_node()                 используйте Node метод get_value(), чтобы вернуть значение  item_to_remove
      self.size -= 1
      return item_to_remove.get_value()
    else:                                                        else оператор. В нем выведите «Эта очередь полностью пуста!»
      print("The queue is totally empty!")
  
  def peek(self):
    if self.size > 0:
      return self.head.get_value()                  peek(), который возвращает value стек, head используя Node метод get_value().
    else:                                            В верхней части peek()тела метода используйте, is_empty()чтобы увидеть, пуста ли очередь.
      print("No orders waiting!")
  
  def get_size(self):                                 метод get_size(), который возвращает sizeсвойство экземпляра.
    return self.size                               
                                                     has_space(). Внутри метода проверьте, self.max_size  был ли установлен a.

                                                   Если нет max_size набора, то у нас всегда будет место в очереди, поэтому мы можем вернутьсяTrue
  def has_space(self):                                 
    if self.max_size == None:                       Если это так, верните True, если max_size больше, чем self.get_size()
      return True
    else:
      return self.max_size > self.get_size()
    
  def is_empty(self):                                is_empty для Queue. Метод должен вернуться True, если очередь пуста (если размер очереди равен 0).
    return self.size == 0

print("Creating a deli line with up to 10 orders...\n------------")
deli_line = Queue(10)
print("Adding orders to our deli line...\n------------")
deli_line.enqueue("egg and cheese on a roll")
deli_line.enqueue("bacon, egg, and cheese on a roll")
deli_line.enqueue("toasted sesame bagel with butter and jelly")
deli_line.enqueue("toasted roll with butter")

deli_line.enqueue("western omelet with home fries")
print("------------\nOur first order will be " + deli_line.peek())
print("------------\nNow serving...\n------------")
deli_line.dequeue()
deli_line.dequeue()
deli_line.dequeue()
-------------------------------------------------------------------------------------------------------------------------------------------------
                                                                          Обзор стеков Python


Стеки:

Содержат узлы данных
Push — добавляет данные на «верх» стека
Pop — возвращает и удаляет данные с «вершины» стека
Peek — возвращает данные с «вершины» стека, не удаляя его
Реализации включают связанный список или массив
Может иметь ограниченный размер
Перемещение данных в полный стек приводит к переполнению стека.
Стекирует данные обработки «последний пришел, первый вышел» (LIFO)

from node import Node
                                                            Stackкласс, который может:
                                                            добавить новый элемент в начало с помощью push()метода
                                                            удалить элемент сверху и вернуть его значение с помощью pop()метода
                                                            вернуть значение верхнего элемента с помощью peek()метода

class Stack:
  def __init__(self, limit=1000):                            limit должен быть принят в качестве параметра со значением по умолчанию 1000. 
    self.top_item = None                                     size должен быть установлен в 0
    self.size = 0
    self.limit = limit                                          Стек push()и pop()методы — это наши инструменты для добавления и удаления элементов из него.
  
  def push(self, value):
    if self.has_space():                                             item(поскольку этот элемент является узлом,
      item = Node(value)                                             top_item используя Node метод set_next_node()
      item.set_next_node(self.top_item)                               Установите экземпляр стека top_itemравным новому 
      self.top_item = item                                              элементу, добавив его в верхнюю часть стека.
      self.size += 1                                           убедиться, что мы отслеживаем размер нашего стека при добавлении новых элементов. 
      print("Adding {} to the pizza stack!".format(value))         увеличьте self.sizeна 1. 
    else:                                                            ifпредложение вверху, .push()которое проверяет, есть ли место в вашем стеке 
      print("No room for {}!".format(value))                        Если есть место, должна выполниться остальная часть тела метода.
                                                                    Если места нет, мы хотим напечатать сообщение,

  def pop(self):                                                    Создайте переменную item_to_remove и установите ее равной стеку top_item
    if not self.is_empty():                                         Если мы удаляем наш стек top_item, нам нужно установить новый top_item!
      item_to_remove = self.top_item                                Установите top_item равный узел после item_to_remove
      self.top_item = item_to_remove.get_next_node()                Вернуть value сохраненное в item_to_remove
      self.size -= 1                                              pop()перед оператором return уменьшите size стек на 1.
      print("Delivering " + item_to_remove.get_value())
      return item_to_remove.get_value()
    print("All out of pizza.")


  def peek(self):                                           peek(), который возвращает value стек, top_item используя Node метод get_value().
    if not self.is_empty():                                 size больше ли значение стека, чем 0.
      return self.top_item.get_value()
    print("Nothing to see here!")                         else предложение с оператором печати, чтобы пользователи знали, что стек пуст.


  def has_space(self):                             .has_space()в Stack. Метод должен вернуть значение True, если self.limit оно больше self.size.
    return self.limit > self.size

  def is_empty(self):                                .is_empty()в Stack.Метод должен вернуться, True если стек size равен 0.
    return self.size == 0                             
                                                        if self.size > 0:теперь можно заменить на if not self.is_empty().
                                                            yuxarida deyisiklik edeceyik pop da ve peek de

  
 #Defining an empty pizza stack
pizza_stack = Stack(6)
 #Adding pizzas as they are ready until we have 
pizza_stack.push("pizza #1")
pizza_stack.push("pizza #2")
pizza_stack.push("pizza #3")


pizza_stack.push("pizza #7")

print("The first pizza to deliver is " + pizza_stack.peek())
pizza_stack.pop()
pizza_stack.pop()
pizza_stack.pop()


pizza_stack.pop()
--------------------------------------------------------------------------------------------------------------------------------------------------
                                                                        Хэш-карта это:

Построен поверх массива с использованием специальной системы индексации.
Общая структура данных, используемая для хранения пар "ключ-значение" и извлекающая значения с использованием соответствующих ключей.
Хранилище ключей и значений с быстрыми назначениями и поиском.
Таблица, представляющая карту из набора ключей в набор значений.
Хеш-карты выполняют все это с помощью хеш-функции, которая превращает ключ в индекс базового массива.
Хэш-функция принимает строку (или данные другого типа) в качестве входных данных
и возвращает индекс массива в качестве выходных данных
Хэш-коллизия — это когда хэш-функция возвращает один и тот же индекс для двух разных ключей.
Кластеризация — это то, что происходит, когда одно столкновение хешей вызывает дополнительные столкновения

  Хэш-открытой адресацией  - Ищет другую ячейку в базовом массиве для добавления значения.
                            Это можно сделать разными методами (линейным, квадратичным и т. д.), но это то, что он делает.
  хеш-карта превращает хэш-код   Использование оператора модуля, обычно с помощью метода сжатия.
  Хэш-функции сжимают данные, поэтому входные данные не могут быть извлечены из собственных выходных данных.

                                                          ХЭШ-КАРТЫ: PYTHON
                                                     Создание класса хэш-карты

class HashMap:
  def __init__(self, array_size):                         список размера array_size. Сделайте каждый элемент .array равным None.
    self.array_size = array_size
    self.array = [None for i in range(self.array_size)]

  def hash(self, key,  count_collisions=0)):             Создание функции Хеш-функции должны быть быстрыми для вычислений, 
    self.key = key                                       Превратите key в список байтов, вызвав key.encode(). 
    key_bytes = key.encode()                             .encode()это строковый метод, который преобразует строку в соответствующие ей байты,
    hash_code = sum(key_bytes)

    return hash_code + count_collisions                   Превратите объект bytes в хэш-код, sum()вызвав key_bytes
                                                          Теперь мы собираемся реализовать открытую систему адресации,
                                                           чтобы наша хеш-карта могла разрешать коллизии . 
                                                          другой параметр: count_collisions. Это будет количество столкновений .hash().



  def compressor(self, hash_code):                         Создание функции сжатия. Функция сжатия использует модульную арифметику для 
    self.hash_code = hash_code                             вычисления индекса массива для хэш-карты при заданном хэш-коде
    return hash_code % self.array_size                     array_size чтобы уменьшить хэш-код до возможного индекса для массива.

  def assign(self, key, value):                           Определение сеттера  установить значение массив в значение, которое мы хотим.
                                                          Сохраните значение (пока только значение) на карте arrayс индексом,
    array_index = self.compressor(self.hash(key))         определенным путем подключения key к .hash()методу и подключения хэш-кода
    self.array[array_index] = value                         к .compressor() методу.
  
  
    current_array_value = self.array[array_index]            мы хотим проверить содержимое, которое в настоящее время находится в self.array[array_index].
    
    if current_array_value == None:                         Во избежание перезаписи неправильного ключа проверьте существующее значение в массиве по адресу
      self.array[array_index] = [key, value]                self.array[array_index]. Сохраните это в current_array_value.
      return 
                                                              Есть три возможности для current_array_value:
    if current_array_value == key:                            Он имеет тот же ключ, что и key.
       self.array[array_index] = [key, value]                 Он имеет другой ключ, чем key.
                                                               Это None.
    
    number_collisions = 1                                     Когда мы заметим, что ключ, который мы пытаемся установить
                                                               отличается от ключа по адресу нашего хэш-кода,
                                                               создайте новую переменную с именем number_collisions, установите ее равной 1.

    while(current_array_value[0] != key):                      while цикл, который проверяет, соответствует ли current_array_value[0] != key.
      new_hash_code = self.hash(key, number_collisions)        Вызов .hash()с помощью key и number_collisions. Сохраните этот результат в new_hash_code.
      new_array_index = self.compressor(new_hash_code)        Подключитесь new_hash_code к .compressor(). Сохраните этот результат в new_array_index.
      current_array_value = self.array[new_array_index]       Проверьте self.array и new_array_index сохраните результат как current_array_value                                                  
     
       if current_array_value is None:                       Если да None, сохраните [key, value]at self.array[new_array_index], а затем return.
         self.array[new_array_index] = [key, value]
         return

       if current_array_value[0] == key:                    Если у него есть значение, но тот же ключ, что и key, перезапишите массив по этому 
         self.array[new_array_index] = [key, value]         адресу с помощью , [key, value]а затем return.
         
         return

      number_collisions += 1                                  Если у него есть значение, но другой ключ, увеличьте number_collisions.
    
     return

  def retrieve(self, key):                                    Определение геттера  .retrieve()должен вычислить индекс массива так же, как и наш 
    self.key = key                                             .assign(), а затем получить значение по этому индексу.
    array_index = self.compressor(self.hash(key))
    return self.array[array_index]

    possible_return_value = self.array[array_index]            Когда мы извлекаем значения хэш-карты,нужно помнить о том, что два ключа могут
    if possible_return_value is None:                          указывать на один и тот же индекс массива.
      return None                                              .retrieve()методе после нахождения индекса массива мы хотим убедиться, 
                                                               что индекс соответствует искомому ключу.
    if possible_return_value[0] == key:                        Сохраните значение массива в нашем сжатом хеш-коде в possible_return_value.
      return possible_return_value[1]                                                         проверьте , совпадает None ли первый элемент в (индекс 0) с .possible_return_value key
                                                               Если это так, верните possible_return_value[1] значение.
   
    retrieval_collisions = 1                                   мы должны продолжить поиск.possible_return_value key
                                                               Определите новую переменную с именем retrieval_collisionsи установите ее равной 1.                                  
                         
                                                                  
    while (possible_return_value[0] != key):                       В цикле while мы хотим воспроизвести нашу логику поиска, увеличивая количество,
      new_hash_code = self.hash(key, retrieval_collisions)         Вызов .hash()с помощью key и retrieval_collisions. Сохраните этот результат в new_hash_code.
      retrieving_array_index = self.compressor(new_hash_code)     Подключитесь new_hash_codeк .compressor(). Сохраните этот результат в retrieving_array_index.
      possible_return_value = self.array[retrieving_array_index]   Проверьте self.arrayи retrieving_array_index сохраните результат как possible_return_value

      if possible_return_value is None:                           Если да None, верни None
        return None

      if possible_return_value[0] == key:                        Если у него есть значение, но другой ключ, увеличьте retrieval_collisions.
        return possible_return_value[1]
                                                                  Если его ключ соответствует нашему key возврату possible_return_value[1].
      retrieval_collisions += 1

    return


hash_map = HashMap(20)                                        Создание экземпляра
hash_map.assign("gneiss", "metamorphic")                       В hash_map сохраните значение "metamorphic"для ключа "gneiss".
print(hash_map.retrieve("gneiss"))                             Теперь получите значение hash_map для ключа gneiss. Распечатайте его,

                                                               Назначьте следующие пары ключ-значение hash_map:
hash_map = HashMap(15)                                         Дайте ему размер массива более 15.
hash_map.assign('gabbro', 'igneous')                           Ключ: 'gabbro', Значение:'igneous'
hash_map.assign('sandstone',  'sedimentary')                   Ключ: 'sandstone', Значение:'sedimentary'
hash_map.assign('gneiss',  'metamorphic')                      Ключ: 'gneiss', Значение:'metamorphic'
print(hash_map.retrieve('gabbro'))
print(hash_map.retrieve('sandstone'))                          Получите значение каждого из трех ключей из hash_map. Распечатайте их!
print(hash_map.retrieve('gneiss'))
-------------------------------------------------------------------------------------------------------------------------------------------------
                                                                     РЕКУРСИЯ: PYTHON
                                                       Создание собственного стека вызовов

def sum_to_one(n):
  result = 1
  call_stack = []
  
  while n != 1:                                         Этот while цикл представляет собой рекурсивные вызовы,
    execution = {"n_value": n}                          которые приводят к базовому варианту.
    call_stack.append(execution)                        Нам нужно зацикливаться до тех пор, пока вход nне достигнет 1
    n -= 1                                              добавить execution в конец call_stack.
                                                        Уменьшение n после того, как его значение было сохранено.
  print(call_stack)                                     Завершите цикл, напечатав call_stack
  print("BASE CASE REACHED")                            распечатайте «BASE CASE REACHED» за пределами блока цикла

                                                       После завершения цикла while мы достигли нашего «базового случая», где n == 1.

                                                       Теперь мы рассмотрим вывод этой функции, где отдельные значения,
                                                        хранящиеся в стеке вызовов, собираются в одно возвращаемое значение.

  while len(call_stack) != 0:                            будем использовать другой while цикл для имитации этого процесса.
    return_value = call_stack.pop()                       цикл будет выполняться до тех пор, пока в файле call_stac

    print("Return value of {0} adding to result {1}".format(return_value['n_value'], result))
    result += return_value['n_value']                  
                                                           Удалите это значение,call_stack иначе у вас будет бесконечный цикл!
    
                                                        Завершите цикл, извлекая "n_value"из return_valueи добавляя его в result.
  return result, call_stack                             

sum_to_one(4)




                                                         Базовый вариант:

                                                         Целое число, заданное в качестве входных данных, равно 1.
def sum_to_one(n):
  if n == 1:
    return n                                              Рекурсивный шаг:
  print("Recursing with input: {0}".format(n))            Рекурсивному вызову функции передается аргумент на 1
                                                           меньше, чем при последнем вызове функции.
  return n + sum_to_one(n - 1)
# uncomment when you're ready to test 
print(sum_to_one(8))
    

                                                            Вот полное рекурсивное решение:
def power_set(my_list):
    # base case: an empty list
    if len(my_list) == 0:
        return [[]]
   
    power = power_set(my_list[1:])
 
    wit = [ [my_list[0]] + rest for rest in power ]
   
    return wit + power
  
universities = ['MIT', 'UCLA', 'Stanford', 'NYU']
power_set_of_universities = power_set(universities)

for set in power_set_of_universities:

  print(set)

                                                             Мы хотим написать функцию, которая удаляет вложенные списки
                                                             внутри списка , но сохраняет содержащиеся в нем значения.
# define flatten() below...
def flatten(my_list):
  result = []
  for i in my_list:                                          Используйте for цикл для повторения my_list.
    if isinstance(i, list):
      print("list found!")
      flat_list = flatten(i)
      result += flat_list                                   flatten()теперь должен вернуть полный результат.
    else:
      result.append(i)
  return result


### reserve for testing...
planets = ['mercury', 'venus', ['earth'], 'mars', [['jupiter', 'saturn']], 'uranus', ['neptune', 'pluto']]
print(flatten(planets))
 

                                                             Определим нашу fibonacci()функцию,


def fibonacci(n):                                           если вход равен 1, мы возвращаем 1
  if n == 1:
    return n
  if n == 0:                                                если ввод равен 0, мы возвращаем 0
    return n
    
    print("Recursive call with {0} as input".format(n))
    return fibonacci(n - 1) + fibonacci(n - 2)
    

fibonacci(9)
fibonacci_runtime = "2^N"
print(fibonacci)
-----------------------------------------------------------------------------------------------------------------------------------------------------
                                                            
                                                                        
                                                                   РЕКУРСИЯ: PYTHON
                                                              Рекурсивные структуры данных
def build_bst(my_list):
  if len(my_list) == 0:                                      Дерево — это структура данных, 
    return "No Child"                                        строит особый тип дерева: бинарное дерево поиска .

  middle_idx = len(my_list) // 2                              «Левый» дочерний элемент дерева должен содержать значение меньше, чем его родитель.
  middle_value = my_list[middle_idx]                          «Правильный» потомок дерева должен содержать значение больше, чем его родитель.
                              
                                                                Базовый случай : список ввода пуст. Вернуться "No Child", чтобы представить отсутствие узла         
  print("Middle index: {0}".format(middle_idx))                    1.Найдите средний индекс списка
  print("Middle value: {0}".format(middle_value))                  2.Сохраните значение, расположенное в среднем индексе
                                                                   3.Создайте узел дерева с "data"ключом, установленным на значение
  tree_node = {"data": middle_value}                               4.Назначьте узлы дерева "left child"рекурсивному вызову, используя левую половину списка.
  tree_node["left_child"] = build_bst(my_list[ : middle_idx])      5.Назначьте узлы дерева "right child"рекурсивному вызову, используя правую половину списка.
  tree_node["right_child"] = build_bst(my_list[middle_idx + 1 : ]) 6.Вернуть узел дерева
                                                             
  return tree_node                                               Установите ключ "left_child"in tree_nodeкак рекурсивный вызов
                                                                 build_bst()с левой половиной списка, не включая среднее значение в качестве аргумента.

                                                                 Установите ключ "right_child"in tree_nodeкак рекурсивный вызов build_bst()с правой
                                                                 половиной списка, не включая среднее значение в качестве аргумента.
  
                                                                  Эта структура данных может использоваться для поиска значений за эффективное O(logN)время.
sorted_list = [12, 13, 14, 15, 16]
binary_search_tree = build_bst(sorted_list)
print(binary_search_tree)
--------------------------------------------------------------------------------------------------------------------------------------------
                                                              РЕКУРСИВНЫЙ И ИТЕРАТИВНЫЙ ОБХОД
                         как мы можем искать элемент в связанном списке, используя итеративный подход.

def find_node_iteratively(self, value):                             Метод начинается с начала связанного списка и проверяет, 
                                                                    value равен ли ввод value переменной экземпляра head_node
  current_node = self.head_node                                     Метод продолжает перебирать связанный список, пока не будет
  while current_node:                                               найден узел или не будет достигнут конец списка.
    if current_node.value == value:                                 Если к концу узел не найден, метод возвращает None.
      return current_node
    current_node = current_node.get_next_node()
 
  return None

----------------------------------------
  from Node import Node                                 bu rekursiv metodun numunesidi

class LinkedList:
  def __init__(self, value=None):                           
    self.head_node = Node(value)
  
  def get_head_node(self):
    return self.head_node
  
  def insert_beginning(self, new_value):
    new_node = Node(new_value)
    new_node.set_next_node(self.head_node)
    self.head_node = new_node
    
  def stringify_list(self):
    string_list = ""
    current_node = self.get_head_node()
    while current_node:
      if current_node.get_value() != None:
        string_list += str(current_node.get_value()) + "\n"
      current_node = current_node.get_next_node()
    return string_list
  
  def remove_node(self, value_to_remove):
    current_node = self.get_head_node()
    if current_node.get_value() == value_to_remove:
      self.head_node = current_node.get_next_node()
    else:
      while current_node:
        next_node = current_node.get_next_node()
        if next_node.get_value() == value_to_remove:
          current_node.set_next_node(next_node.get_next_node())
          current_node = None
        else:
          current_node = next_node
    
  def find_node_iteratively(self, value):
    current_node = self.head_node
    
    while current_node:
      if current_node.value == value:
        return current_node
      current_node = current_node.get_next_node()
      
    return None

  def find_node_recursively(self, value, current_node):
    if current_node == None:
      return None
    elif current_node.value == value:
      return current_node
    else:
      return self.find_node_recursively(value, current_node.get_next_node())
-------------------------------------------------------------------------------------------------------------------------------------------
                                                         rekursivniy metod               

          Функция должна возвращать копию lst с каждым экземпляром, val перемещенным в конец списка.

Сначала мы создаем пустую переменную списка с именем result— мы будем использовать эту переменную для хранения выходного списка.

Базовый случай проверяет, lstявляется ли пустым с помощью if len(lst) == 0. Если он пуст, мы возвращаем пустой список [].

Далее переходим к рекурсивному шагу. Если первый элемент соответствует val, нам нужно извлечь первый элемент из lstи добавить его в конецresult . 
Это достигается путем рекурсивного вызова result += move_to_end(lst[1:], val) сначала , а затем добавления элемента с помощью result.append(lst[0]).
 Мы используем lst[1:]здесь в качестве аргумента, чтобы приблизить ввод к базовому случаю.

В elseразделе, где первый элемент НЕ соответствует val, нам нужно извлечь первый элемент из lstи добавить его в началоresult . 
Это достигается добавлением элемента с помощью result.append(lst[0]), а затем рекурсивным вызовом result += move_to_end(lst[1:], val) second .

Наконец, функция возвращает result. После того, как рекурсивные вызовы будут возвращены из стека вызовов, resultбудет копия lstс каждым экземпляром, 
valперемещенным в конец списка.


def move_to_end(lst, val):
  result = []
  if len(lst) == 0:
    return []
 
  if lst[0] == val:
    result += move_to_end(lst[1:], val)
    result.append(lst[0])
  else:
    result.append(lst[0])
    result += move_to_end(lst[1:], val)
 
  return result

                                                            Удалить i-й узел из связанного списка

мы выполнim вышеуказанную задачу с помощью рекурсии:

Функция должна удалить ith узел связанного списка (индекс от 0) и вернуть измененный head файл .

Мы позаботимся о пограничном случае, когда i <= 0невозможно удалить узел с отрицательным индексом. Хорошей практикой является устранение таких пограничных 
случаев в вашей программе, чтобы она всегда работала должным образом.

Затем мы определяем два базовых случая:

Первый базовый случай включает проверку if head is None. Если это True, мы знаем, что достигли конца связанного списка, поэтому мы просто возвращаем объект None.
Второй базовый случай включает проверку if i == 0и удаление headиз связанного списка. Самый простой способ удалить head— пропустить его и вернуться
 head.next_nodeвместо него.
Чтобы перебрать связанный список, мы присваиваем head.next_nodeрекурсивный вызов. remove_node()вызывается рекурсивно с аргументами head.next_nodeи i - 1,
 что одновременно перемещает входные данные ближе к первому и второму базовым случаям.

Последний шаг — вернуться head. После разрешения всех рекурсивных вызовов в стеке вызовов headбудет первым узлом связанного списка с iудаленным узлом th.

def remove_node(head, i):
    if i < 0:
        return head
    if head is None:
        return None
    if i == 0:
        return head.next_node
 
    head.next_node = remove_node(head.next_node, i - 1)
    return head

                                                        Подготовить и добавить к строке

Функция должна возвращать копию strс nчислом '<'и '>'добавленным к нему и добавленным к нему соответственно.

Как и в первой задаче, мы будем использовать переменную, вызываемую resultдля хранения выходной строки.

В базовом случае мы проверяем if n <= 0, и в этом случае мы просто возвращаем развернутый str.

Рекурсивный шаг происходит между двумя итеративными операторами. <добавляется resultперед рекурсивным вызовом и >добавляется resultпосле рекурсивного 
вызова. Посередине wrap_string()вызывается with , n-1чтобы приблизить ввод на один шаг к базовому варианту. result
Возвращаемое значение этого рекурсивного вызова также объединяется .

Используя этот подход, resultбудет выполняться слой за слоем из-за порядка возврата стека вызовов. Например, когда мы вызываем wrap_string("Pearl", 3), 
стек вызовов будет возвращаться в следующем порядке: Pearl-> <Pearl>-> <<Pearl>>-> <<<Pearl>>>.
  

def wrap_string(str, n):
  result = ""
  if n <= 0:
    return str
  result += "<"
  result += wrap_string(str, n-1)
  result += ">"
 
  return result
-------------------------------------------------------------------------------------------------------------------------------------------------------------
                              Мы используем асимптотическую запись для описания времени выполнения программы. 
                             Существует три типа асимптотических обозначений: большая тета, большая омега и большая О.

Мы используем большие тета (Θ) для описания времени выполнения, если время выполнения программы одинаково во всех случаях.

Различные общие времена выполнения от самого быстрого до самого медленного:Θ(1), Θ(log N), Θ(N), Θ(N log N), Θ(N2), Θ(2N), Θ(N!).

Мы используем большую омегу (Ω) для описания наилучшего времени работы программы.

Мы используем большое O (O) для описания времени выполнения программы в наихудшем случае.

                                         Лучший случай	            Худший случай	             Средний случай	           Космическая сложность
Пузырьковая сортировка(Bubble Sort)          Ом (н)	               О (п ^ 2)	                 О (п ^ 2)	                    О(1)

Сортировка слиянием(Merge sort)	         Ω(n log n)	              O (n log n)	                O (n log n)	                    O(n)

Быстрая сортировка(Quicksort)	         Ω(n log n)	               О (п ^ 2)        	       O (n log n)     	                 О (log п)

---------------------------------------------------------------------------------------------------------------------------------------
def remove_n_nodes(doubly_linked_list, n):  
while n > 0:
    # remove head
    doubly_linked_list.remove_head()

    # decrement n by 1
    n = n - 1
--------------------------------------------------------------------------------------------------------------------------------------
                                                                   АСИМПТОТИЧЕСКАЯ ЗАПИСЬ: PYTHON

                                              Функция , find_maxпринимает linked_listв качестве входных данных.
                                              Функция должна возвращать максимальное значение в связанном списке.


from linkedlist import LinkedList                    максимальное значение linked_list, проходя только linked_list один раз.

#Fill in Function                                      Заполните find_maxфункцию так, чтобы вы возвращали максимальное 
def find_max(linked_list):                             значение linked_list, проходя только linked_listодин раз.
  print("--------------------------")
  print("Finding the maximum value of:\n{0}"
          .format(linked_list.stringify_list()))

  current = linked_list.get_head_node()
  maximum = current.get_value()
  while current.get_next_node():
    current = current.get_next_node()
    val = current.get_value()
    if val > maximum:
      maximum = val                                   Тестовые случаи были предоставлены для вас,
  return maximum
                                                                      Сортировка связанного списка


def sort_linked_list(linked_list):
  print("\n---------------------------")
  print("The original linked list is:\n{0}".                      Создание нового связанного списка
  format(linked_list.stringify_list()))                          Найдите максимальное значение нашего введенного связанного списка
                                                                 Вставьте максимум в начало нового связанного списка
  new_linked_list = LinkedList()                                 Удалить максимальное значение из введенного связанного списка
  
  while linked_list.get_head_node():                             Повторяйте шаги 2-4, пока головной узел введенного связанного списка не укажет на None
   current_max = find_max(linked_list)                           Вернуть новый связанный список
   linked_list.remove_node(current_max)
   new_linked_list.insert_beginning(current_max)
  
  return new_linked_list

ll = LinkedList(6)
ll.insert_beginning(32)
ll.insert_beginning(-12)
ll.insert_beginning(48)
print("The maximum value in this linked list is {0}\n".format(find_max(ll)))

-----------------------------------------------------------------------------------------------------------------------------------------------
                                                                  iterativniy poisk
def binarySearch(sorted_list, search_value):
  
  left_pointer = 0
  right_pointer = len(sorted_list) - 1
  while left_pointer <= right_pointer:
    mid_pointer = (left_pointer + right_pointer) // 2
    if search_value == sorted_list[mid_pointer]:
      return mid_pointer
    if search_value < sorted_list[mid_pointer]:
      right_pointer = mid_pointer - 1
    if search_value > sorted_list[mid_pointer]:
      left_pointer = mid_pointer + 1
  
  return "Value not in list"
------------------------------------------------------------------------------------------------------------------------------------------------
                                                                         БИНАРНЫЙ ПОИСК: PYTHON

Мы знаем, что наши входные данные будут отсортированы, что помогает нам делать утверждения о том, где искать значения.
Делим список пополам и сравниваем наше целевое значение со средним элементом.
Если они совпадают, мы возвращаем индекс
Если они не совпадают, мы снова начинаем с первого шага с соответствующей половины исходного списка.
Когда список пуст, цель не найдена.
Наше исходное решение решило проблему сокращения отсортированного входного списка за счет создания уменьшенной копии списка.

Наша общая стратегия та же, но нам нужно изменить следующие разделы:

binary_search()имеет два параметра
Должно быть четыре
Наш базовый случай проверяет пустой список
Он должен проверить, указывают ли указатели на пустой подсписок
Наши рекурсивные вызовы используют скопированные подсписки
Они должны обновить указатели, чтобы указать, какую часть списка мы ищем.
Наши рекурсивные вызовы «правой половины» выполняют некоторые арифметические действия.
Это больше не нужно!

def binary_search(sorted_list, left_pointer, right_pointer, target):
  # this condition indicates we've reached an empty "sub-list"
  if left_pointer >= right_pointer:
    return "value not found"
	
  mid_idx = (left_pointer + right_pointer) // 2
  mid_val = sorted_list[mid_idx]

  if mid_val == target:
    return mid_idx
  if mid_val > target:
    return binary_search(sorted_list, left_pointer, mid_idx, target)

  if mid_val < target:
    return binary_search(sorted_list, mid_idx + 1, right_pointer, target)
  
values = [77, 80, 102, 123, 288, 300, 540]
start_of_values = 0
end_of_values = len(values)
result = binary_search(values, start_of_values, end_of_values, 288)

print("element {0} is located at index {1}".format(288, result))
-------------------------------------------------------------------------------------------------------------------------------------------------------
                                                             Итеративный бинарный поиск
Наша стратегия во многом остается такой же, как и при рекурсивном подходе, в котором использовались указатели.

Вместо рекурсивных вызовов подставим цикл while.

def binary_search(sorted_list, target):
  left_pointer = 0
  right_pointer = len(sorted_list)
  
  # fill in the condition for the while loop
  while left_pointer < right_pointer:
    # calculate the middle index using the two pointers
    mid_idx = (left_pointer + right_pointer) // 2
    mid_val = sorted_list[mid_idx]
    if mid_val == target:
      return mid_idx
    if target < mid_val:
      # set the right_pointer to the appropriate value
      right_pointer = mid_idx
    if target > mid_val:
      # set the left_pointer to the appropriate value
      left_pointer = mid_idx + 1
  
  return "Value not in list"

# test cases
print(binary_search([5,6,7,8,9], 9))
print(binary_search([5,6,7,8,9], 10))
print(binary_search([5,6,7,8,9], 8))
print(binary_search([5,6,7,8,9], 7))
print(binary_search([5,6,7,8,9], 6))
--------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                      Деревья
                  В частности, деревья используются для данных, имеющих иерархическую структуру, 
                  таких как генеалогическое древо или файловая система компьютера.

                                                               Бинарные деревья поиска
                  Двоичные деревья поиска — это тип древовидной структуры данных с
                  добавленным условием, что каждый элемент слева от узла должен быть меньше, чем этот родительский узел, 
                  и каждый элемент справа от узла должен быть больше, чем этот родительский узел.
 
                                                               Кучи
                 Кучи — это еще один вариант древовидной структуры данных, способный отслеживать максимальное или
                 минимальное значение, хранящееся внутри, называемое максимальными и минимальными кучами соответственно.
                  В частности, кучи — это тип двоичного дерева, поскольку каждый дочерний узел больше 
                  или меньше своего родителя (в зависимости от того, является ли он максимальной кучей или минимальной кучей).

-----------------------------------------------------------------------------------------------------------------------------------------------
                                                                          Обзор дерева
                   1.root: Узел, у которого нет родителя. По одному на дерево.
                   2.parent: узел, который ссылается на другие узлы.
                   3.child: узлы, на которые ссылаются другие узлы.
                   4.sibling: узлы, имеющие одного и того же родителя.
                   5.leaf: узлы, у которых нет потомков.
                   6.level: Высота или глубина дерева. Корневые узлы находятся на уровне 1, их дочерние узлы — на уровне 2 и так далее.
-----------------------------------------------------------------------------------------------------------------------------------------------------
                                                                              ДЕРЕВЬЯ: ПИТОН

class TreeNode:
  def __init__(self, value):
    self.value = value # data
    self.children = [] # references to other nodes                      нашем TreeNode классе, который будет добавлять узлы в этот список.

  def add_child(self, child_node):
    # creates parent-child relationship
    print("Adding " + child_node.value)
    self.children.append(child_node)                                      добавить child_node в self.children.
    
  def remove_child(self, child_node):                                      Вызов .remove_child определенного узла.
                                                                           Передать другой узел в качестве аргумента
    print("Removing " + child_node.value + " from " + self.value)          Удалите из .children любых узлов, которые соответствуют узлу-аргументу.
    self.children = [child for child in self.children                      Переберите self.children и добавьте в new_children список любой элемент
                     if child is not child_node]                           который не совпадает с child_node аргументом.
                                                                           Когда итерация закончится, назначьте self.children список new_children.
  def traverse(self):
    # moves through each node referenced from self downwards              Обход дерева — это стандартная операция поиска узлов с
    nodes_to_visit = [self]                                                определенным значением или вывода всех узлов,доступных в дереве.
    while len(nodes_to_visit) > 0:                                         После печати self.value выполните цикл self.children и напечатайте их значения.
      current_node = nodes_to_visit.pop()                                  После этого nodes_to_visit создайте цикл while,
                                                                           который будет выполняться до тех пор, пока в нем есть элементы nodes_to_visit.
      print(current_node.value)                                            создайте новую переменную current_node и присвойте ей значение nodes_to_visit.pop().
      nodes_to_visit += current_node.children
root = TreeNode("Geo")                                                     После печати current_node.value добавить current_node.children в nodes_to_visit.
first = TreeNode("one")                                                    Добавляя потомков узла, мы обеспечиваем обход всего дерева .
two = TreeNode("Jon")
root.add_child(first)                                                      Вызовите и передайте remove_child в качестве аргумента.root bad_seed
root.traverse()

                                                            Для обзора в нашей реализации:

Деревья — это класс Python, называемый TreeNode.

A TreeNodeимеет два свойства, valueи children.

Узлы содержат внутри себя данные любого типа value.

children это список, который может быть пустым или содержать другие экземпляры TreeNode.

Мы добавляем children, используя метод списка .append.

Мы удаляем из children путем фильтрации списка.
-----------------------------------------------------------------------------------------------------------------------------------------------------

import random                                                               binarniy dereva poisk

class BinarySearchTree:
  def __init__(self, value, depth=1):                               value данные содержатся в двоичном дереве поиска и depthу казывают уровень дерева.
    self.value = value
    self.depth = depth                                             left переменные right экземпляра, которые будут представлять левый и правый узлы поддерева,
    self.left = None
    self.right = None

  def insert(self, value):                                         Если левый дочерний элемент текущего узла еще не существует, мы создаем новый
    if (value < self.value):                                       BinarySearchTree узел с этим значением в качестве левого дочернего элемента этого узла.
      if (self.left is None):                                      Если левый дочерний элемент уже существует, мы будем .insert()рекурсивно вызывать левого
        self.left = BinarySearchTree(value, self.depth + 1)        дочернего элемента текущего узла, чтобы вставить его дальше вниз.
        print(f'Tree node {value} added to the left                правой стороны. Логика для этого будет аналогична:
             of {self.value} at depth {self.depth + 1}')           производительность будет .Nlog(N)log(N)O(N)
      else:                                                                                                                          100
        self.left.insert(value)                                                                                                     /   \           
                                                                                                                                   50   125
    else:                                                                                                                         /  \
      if (self.right is None):                                                                                                  25   75
        self.right = BinarySearchTree(value, self.depth + 1)
        print(f'Tree node {value} added to the right 
             of {self.value} at depth {self.depth + 1}')
      else:
        self.right.insert(value)
        
  def get_node_by_value(self, value):                                                   Получение узла по значению
    if (self.value == value):                                                           Напишем базовый случай.
      return self                                                                       Если целевое значение не может быть найдено в корневом узле,
    elif ((self.left is not None) and (value < self.value)):                            перейти дальше вниз по двоичному дереву поиска. 
      return self.left.get_node_by_value(value)                                         если он существует, и рекурсивно ищем в левом поддереве
    elif ((self.right is not None) and (value >= self.value)):                  если left дочерний узел существует И если целевое значение меньше self.value
                                                                                Внутри elif блока вернитесь с вызовом метода .get_node_by_value() из
      return self.right.get_node_by_value(value)                                left дочернего узла, передав value.
    else:                                                                       Напишите elif оператор, который проверяет:  если right дочерний узел существует
      return None                                                               Внутри elif блока вернитесь с вызовом метода .get_node_by_value() ,  передав value.
                                                                                Если ни одно из предыдущих условий не соответствует True
                                                                                Создайте else блок, который возвращает None.    O(logN)

  
                                                                              Существует два основных способа обхода бинарного дерева: в ширину и в глубину
                                           
                                                                                       При обходе в глубину
                                                                               Предварительный порядок — это когда мы сначала выполняем действие с текущим узлом, 
                                                                                           а затем с его левым дочерним узлом и его правым дочерним узлом.
                                                                               Порядок — это когда мы сначала выполняем действие над левым дочерним узлом, 
                                                                                           затем над текущим узлом и над правым дочерним узлом.  
                                                                               Постпорядок — это когда мы сначала выполняем действие над левым дочерним узлом, 
                                                                                           затем над правым дочерним узлом, а затем над текущим узлом.
                                                                               Для этого урока мы реализуем вариант обходa

def depth_first_traversal(self):                                             Затем внутри .depth_first_traversal():Проверьте, существует ли левый дочерний узел
    if (self.left is not None):                                              Если это так, вызовите этот метод на левом дочернем узле.
      self.left.depth_first_traversal()                                      if, добавьте следующий оператор печати, который будет печатать корневые узлы depthи value:
    print(f'Depth={self.depth}, Value={self.value}')
    if (self.right is not None):                                             Проверяет, существует ли правильный дочерний узел
                                                                             Если это так, вызывает этот метод на правом дочернем узле.
      self.right.depth_first_traversal()                                     распечатать неупорядоченный обход дерева.   O(N)


print("Creating Binary Search Tree rooted at value 15:")
tree = BinarySearchTree(15)

for x in range(10):
  tree.insert(random.randint(0, 100))
  
print("Printing the inorder depth-first traversal:")
tree.depth_first_traversal()
--------------------------------------------------------------------------------------------------------------------------------
                                                                  Обзор минимальной кучи
 class MinHeap:
  def __init__(self):                                           Min-yığınlar, müqayisələr tərsinə çevrilməklə, max-heap ilə demək olar ki, eynidir. 
    self.heap_list = [None]                                     Min-Heap müəyyənləşdirilməsi
    self.count = 0                                              MinHeapiki məlumat saxlayacaq:

                                                                Yığın içindəki elementlərin Python siyahısı.
                                                                Yığın içindəki elementlərin sayı.
                                                                biz həmişə siyahının başında bir gözətçi None elementi saxlayacağıq:
                                                                Elementin əlavə edilməsi: Heapify Up I
                                                                Bizim MinHeap iradəmiz iki prinsipə tabedir:
  def parent_idx(self, idx):                                      İndeksdəki element bütün siyahıdakı minimum1 dəyərdir .
    return idx // 2                                               Siyahıdakı hər bir “uşaq” element “valideyn”indən böyük olmalıdır.

  def left_child_idx(self, idx):                                  Siyahıya əlavə etdiyimiz ilk element minimum olacaq, çünki başqa elementlər yoxdur.
    return idx * 2
                                                                                   Valideyn:index // 2
  def right_child_idx(self, idx):                                                  Sol Uşaq:index * 2
    return idx * 2 + 1                                                             Sağ Uşaq:(index * 2) + 1
                                                                  biz üç köməkçi metod əlavə etdik: .parent_idx(), .left_child_idx(), və .right_child_idx().

                                                                .child_present(). Bu, verilmiş indeksin əlaqəli uşaq elementə malik olub-olmadığını
  def child_present(self, idx):                                  göstərən bir boolean qaytarır. Ağıllı istifadə edin.
    return self.left_child_idx(idx) <= self.count
  

  def retrieve_min(self):                                            Daxili sayımızın olub olmadığını yoxlayın 0…
    if self.count == 0:                                              Əgər belədirsə, əldə etmək üçün heç bir elementimiz yoxdur, ona görə də
      print("No items in heap")                                      "Yığında element yoxdur" yazısını çap edin və geri qaytarın None.
      return None
                                                                   Sonra, indeksdəki elementi 1 daxili siyahıdakı sonuncu elementlə dəyişdirin.
    min = self.heap_list[1]
    self.heap_list[1] = self.heap_list[self.count]                 Siyahıdan sonuncu elementi çıxarın və sayını azaldın.
    self.count -= 1
    self.heap_list.pop()
    self.heapify_down()
    return min

  def add(self, element):                                    Daxili .add()elementlərin sayını artırın, sonra elementi daxili siyahının sonuna əlavə edin.
    self.count += 1
    self.heap_list.append(element)
    self.heapify_up()
                                                                 Məqsədimiz minimum elementi yığından səmərəli şəkildə çıxarmaqdır

  def get_smaller_child_idx(self, idx):                           Uşaqları olmayan elementi silməliyik; son elementi silməliyik .
    if self.right_child_idx(idx) > self.count:                    
      return self.left_child_idx(idx)                             köməkçi üsullarımızdan çox istifadə edəcəyik: .left_child_idx()və .right_child_idx().
    else:                                                           
                                                                  Əgər düzgün uşağımız varsa , hansının daha kiçik olduğunu görmək üçün müqayisə aparmalıyıq.
      left_child = self.heap_list[self.left_child_idx(idx)]
      right_child = self.heap_list[self.right_child_idx(idx)]
      if left_child < right_child:
        return self.left_child_idx(idx)
      else:
        return self.right_child_idx(idx)
    
  def heapify_up(self):                                                Elementin indeksi üzərində bəzi hesablama aparmaqla biz ana və uşaq elementlər
    idx = self.count                                                   üçün indeksləri (əgər onlar varsa) müəyyən edə bilərik.
    swap_count = 0                                                     idx və onu daxili siyahının sonuncu indeksinə təyin edin.
    while self.parent_idx(idx) > 0:                                    Etibarlı valideyn indeksi -dən böyükdür 0.      
      if self.heap_list[self.parent_idx(idx)] > self.heap_list[idx]:   Döngənin içərisində idxonun əsas indeksi olaraq təyin edin.       
        swap_count += 1                                                child və onu daxili siyahıdakı elementə bərabər təyin edin idx.       
        tmp = self.heap_list[self.parent_idx(idx)]                      parentvə onu daxili siyahıdakı elementə bərabər təyin edin self.parent_idx(idx).
        self.heap_list[self.parent_idx(idx)] = self.heap_list[idx]
        self.heap_list[idx] = tmp
      idx = self.parent_idx(idx)

    element_count = len(self.heap_list)
    if element_count > 10000:
      print("Heap of {0} elements restored with {1} swaps"
            .format(element_count, swap_count))
      print("")    
                                                                       .heapify_down()-a oxşar rolu yerinə yetirən metodu müəyyən edəcəyik , 
  def heapify_down(self):                                               ancaq indi yuxarı əvəzinə "ağac" ilə aşağı.heapify_up() hərəkət edirik .
    idx = 1 
    swap_count = 1                                                      minimumu çıxararkən dəyişdirdiyimiz yersiz dəyərimizə işarə edir.
    while self.child_present(idx):
      smaller_child_idx = self.get_smaller_child_idx(idx)                heapify_down()bizim potensial olaraq iki seçimimiz var: sol uşaq və sağ uşaq.
      if self.heap_list[idx] > self.heap_list[smaller_child_idx]:       Biz iki uşaqdan daha kiçik olanı dəyişdirmək istəyirik , 
        swap_count += 1                                                 əks halda yığın xüsusiyyətlərimizi qoruya bilmərik!
        tmp = self.heap_list[smaller_child_idx]                         
        self.heap_list[smaller_child_idx] = self.heap_list[idx]
        self.heap_list[idx] = tmp
      idx = smaller_child_idx

    element_count = len(self.heap_list)
    if element_count >= 10000:
      print("Heap of {0} elements restored with {1} swaps"
            .format(element_count, swap_count))
      print("")  
------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                     Макс-кучи

Max-heap отслеживает максимальный элемент как элемент в наборе данных.
Max-heaps должны поддерживать свойство кучи, согласно которому родительские значения должны быть больше, чем их дочерние.
При добавлении элементов мы используем .heapify_up()для сравнения нового элемента с его родителем; если это нарушает свойство кучи, 
то мы должны поменять местами два значения.

.add()будет обрабатывать добавление элемента в кучу через .heap_listсвойство.
.heapify_up()будет выполнять работу по поддержанию свойств кучи по мере добавления дополнительных элементов.

родительского и дочернего элементов (если они существуют).

Родитель:index // 2
Левый ребенок:index * 2
Правый ребенок:(index * 2) + 1

print(heap.heap_list)
# Outputs: [None, 99, 22, 61, 10, 21, 13, 23]
# Indices: [0, 1, 2, 3, 4, 5, 6, 7]
 
heap.parent_idx(4)
# (4 // 2) == 2
# Element at index 4 is 10 
# Element at index 2 is 22
# The parent element of 10 is 22
 
heap.left_child(3)
# (3 * 2) == 6
# Element at index 3 is 61
# Element at index 6 is 13
# The left child element of 61 is 13

поэтому мы добавили три вспомогательных метода: возвращают соответствующий родительский или дочерний индекс.

.parent_idx(), .left_child_idx()  и .right_child_idx().

Давайте подытожим то, что мы узнали:

Max-heap отслеживает максимальный элемент как элемент по индексу 1во внутреннем списке Python.
Max-heaps должны поддерживать свойство кучи, согласно которому родительские значения должны быть больше, чем их дочерние элементы .
При добавлении элементов мы используем .heapify_up()для сравнения нового элемента с его родителем; если это нарушает свойство кучи,
 то мы должны поменять местами два значения

class MaxHeap:
  def __init__(self):
    self.heap_list = [None]
    self.count = 0

  # HEAP HELPER METHODS
  # DO NOT CHANGE!
  def parent_idx(self, idx):
    return idx // 2

  def left_child_idx(self, idx):
    return idx * 2

  def right_child_idx(self, idx):
    return idx * 2 + 1

  # END OF HEAP HELPER METHODS
  
  def add(self, element):
    self.count += 1
    print("Adding: {0} to {1}".format(element, self.heap_list))
    self.heap_list.append(element)
    self.heapify_up()
    
  def heapify_up(self):
    print("Heapifying up")
    idx = self.count                                                                добавления элемента в конец списка мы
    while self.parent_idx(idx) > 0:
      child = self.heap_list[idx]
      parent = self.heap_list[self.parent_idx(idx)]
      if parent < child:
        print("swapping {0} with {1}".format(parent, child))
        self.heap_list[idx] = parent
        self.heap_list[self.parent_idx(idx)] = child
      idx = self.parent_idx(idx)
    print("Heap Restored {0}".format(self.heap_list))

------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
-                                                                                      Heapsort
Heapsort — это алгоритм , который сортирует массивы, вставляя данные в структуру данных кучи, а затем многократно извлекая корень кучи. 
Heapsort является особенно эффективным по времени алгоритмом из-за его O(n log n)временной сложности в каждом случае.

  Вот как мы реализуем пирамидальную сортировку:

Создайте максимальную кучу для хранения данных из несортированного списка.
Извлеките наибольшее значение из кучи и поместите его в отсортированный список.
Замените корень кучи последним элементом в списке. Затем перебалансируйте кучу.
Как только max-heap опустеет, верните отсортированный список

   Heapsort — это алгоритм сортировки, который использует структуру данных кучи для сортировки списка в порядке возрастания.

Сначала добавьте значения несортированного списка в максимальную кучу.
Затем, пока в куче есть хотя бы один элемент, поменяйте местами размещение наибольшего значения в куче с последним значением в куче.
После того, как значения поменялись местами, удалите последний элемент в куче и поместите его в список, который будет возвращен в конце. 
Каждый раз, когда мы меняем местами и извлекаем корень, мы должны перебалансировать кучу.
Наконец, верните отсортированный список.

 Наша цель — эффективно удалить максимальный элемент из кучи, чтобы поместить его в наш
отсортированный список. Мы выполним эту задачу, создав .retrieve_max()метод, который делает следующее:

Меняет местами первый и последний элемент.
Удаляет и возвращает наибольшее значение.
Перебалансирует существующую кучу.

.heapify_down()что это очень похоже на .heapify_up(): мы отслеживаем проблемный элемент в куче и продолжаем заменять 
его другим элементом, пока не восстановим свойства кучи.

 метод с именем .get_larger_child_idx(). Его цель будет заключаться в том, чтобы вернуть индекс дочернего элемента с большим значением.

метод: .child_present(). Это возвращает логическое значение,указывающее, имеет ли данный индекс связанный с ним дочерний элемент.

class MaxHeap:
  def __init__(self):
    self.heap_list = [None]
    self.count = 0

  # HEAP HELPER METHODS
  # DO NOT CHANGE!
  def parent_idx(self, idx):
    return idx // 2

  def left_child_idx(self, idx):
    return idx * 2

  def right_child_idx(self, idx):
    return idx * 2 + 1

  def child_present(self, idx):
    return self.left_child_idx(idx) <= self.count

  # END OF HEAP HELPER METHODS
  
  def add(self, element):
    self.count += 1
    print("Adding: {0} to {1}".format(element, self.heap_list))
    self.heap_list.append(element)
    self.heapify_up()
    
  def heapify_up(self):
    print("Heapifying up")
    idx = self.count
    while self.parent_idx(idx) > 0:
      child = self.heap_list[idx]
      parent = self.heap_list[self.parent_idx(idx)]
      if parent < child:
        print("swapping {0} with {1}".format(parent, child))
        self.heap_list[idx] = parent
        self.heap_list[self.parent_idx(idx)] = child
      idx = self.parent_idx(idx)
    print("Heap Restored {0}".format(self.heap_list))

  def retrieve_max(self):
    if self.count == 0:
      print("No items in heap")
      return None
    max_value = self.heap_list[1]
    print("Removing: {0} from {1}".format(max_value, self.heap_list))
    self.heap_list[1] = self.heap_list[self.count]
    self.count -= 1
    self.heap_list.pop()
    print("Last element moved to first: {0}".format(self.heap_list))    
    self.heapify_down()
    return max_value

  def heapify_down(self):
    idx = 1
    while self.child_present(idx):
      print("Heapifying down!")
      larger_child_idx = self.get_larger_child_idx(idx)
      child = self.heap_list[larger_child_idx]
      parent = self.heap_list[idx]
      if parent < child:
        self.heap_list[idx] = child
        self.heap_list[larger_child_idx] = parent
      idx = larger_child_idx
    print("HEAP RESTORED! {0}".format(self.heap_list))
    print("") 

  def get_larger_child_idx(self, idx):
    if self.right_child_idx(idx) > self.count:
      print("There is only a left child")
      return self.left_child_idx(idx)
    else:
      left_child = self.heap_list[self.left_child_idx(idx)]
      right_child = self.heap_list[self.right_child_idx(idx)]
      if left_child > right_child:
        print("Left child "+ str(left_child) + " is larger than right child " + str(right_child))
        return self.left_child_idx(idx)
      else:
        print("Right child " + str(right_child) + " is larger than left child " + str(left_child))
        return self.right_child_idx(idx)

   script.ry ise bu olacag

from max_heap import MaxHeap 

def heapsort(lst):
  sort = []
  max_heap = MaxHeap()
  for idx in lst:
    max_heap.add(idx)
  while max_heap.count > 0:
    max_value = max_heap.retrieve_max()
    sort.insert(0, max_value)
  return sort

my_list = [99, 22, 61, 10, 21, 13, 23]
sorted_list = heapsort(my_list)
print(sorted_list)

Одним из первых шагов в реализации алгоритма пирамидальной сортировки является помещение списка значений в структуру кучи.
----------------------------------------------------------------------------------------------------------------------------------------------------------------- 

                                                                     СОРТИРОВКА СЛИЯНИЕМ
                                                 для своего времени тем, что лучшая, худшая и средняя временная сложность одинаковы: Θ(N*log(N)).
                                                 Сортировка слиянием также требует места.
                                                 наихудшая пространственная сложность сортировки слиянием равна O(N).

                                                 Первым шагом в сортировке слиянием является разделение данных на более мелкие списки. 
def merge_sort(items):                           Мы собираемся использовать merge_sort()разбивку itemsна все более мелкие списки,
  if len(items) <= 1:                            а затем напишем merge()функцию, которая объединит их вместе.
    return items                                 Наш первый шаг — разбить все элементы списка на отдельные списки.
                                                 содержащих менее 2 элементов, мы разделяем все, что длиннее.
  middle_index = len(items) // 2                 middle_index, которая является индексом среднего элемента в списке.
  left_split = items[:middle_index]              left_split. Это должен быть список всех элементов в списке ввода, 
  right_split = items[middle_index:]             начиная с первого до элемента , но не включая его middle_index.
                                                 right_split, которая включает все элементы items от middle_index до конца списка.

                                                 мы собираемся определить вспомогательную функцию, которая объединяет данные вместе.

                       axirda ------->           Давайте обновим нашу merge_sort()функцию, чтобы она, наконец, возвращала отсортированный список!
                                                                                    |
                                                                                    :
  left_sorted = merge_sort(left_split)          left_sortedдолжен быть результатом merge_sort()рекурсивного вызова left_split.
  right_sorted = merge_sort(right_split)        right_sortedдолжен быть результатом merge_sort()рекурсивного вызова right_split

  return merge(left_sorted, right_sorted)

def merge(left, right):                         два параметра: leftи right. Это будут два (отсортированных) списка, которые мы хотим объединить.
  result = []                                   добавлять элементы leftи rightc до тех result пор, пока он не будет 
                                                содержать отсортированный список со всеми элементами обоих.
                                                Создайте while  цикл, который будет продолжать повторяться, пока оба left и right имеют элементы.
  while (left and right):                       Когда один из этих двух пуст, мы хотим двигаться дальше.
    if left[0] < right[0]:                      Проверьте, меньше ли первый элемент (помните, индекс 0), left чем первый элемент right. 
      result.append(left[0])                   sonra yoxlayirig ve left elave edirik cikl garismasin deye elave olunan element pop ile silirik 
      left.pop(0)                               hemin seyi right edirik 
    else:
      result.append(right[0])              
      right.pop(0)

  if left:                                     cikldn sonra yoxlayirig eger left varsa result eleve edeceyik eyniyle rightda edirik.
    result += left
  if right:
    result += right

  return result

мы поместили три ненумерованных списка: unordered_list1, unordered_list2 и unordered_list3.

unordered_list1 = [356, 746, 264, 569, 949, 895, 125, 455]
unordered_list2 = [787, 677, 391, 318, 543, 717, 180, 113, 795, 19, 202, 534, 201, 370, 276, 975, 403, 624, 770, 595, 571, 268, 373]
unordered_list3 = [860, 380, 151, 585, 743, 542, 147, 820, 439, 865, 924, 387]
ordered_list1 = merge_sort(unordered_list1)
ordered_list2 = merge_sort(unordered_list2)
ordered_list3 = merge_sort(unordered_list3)
print(merge_sort(unordered_list1))
print(ordered_list2)

print(ordered_list3) 
                       Вся сортировка выполняет две функции:

                     merge_sort() который называется рекурсивно разбивает входной список на более мелкие
                     merge_sort() продолжает разбивать входной список до тех пор, пока в нем не будет только один элемент
                                  ,а затем он объединяет его с другими списками с одним элементом
                                  для создания отсортированных списков из 2 элементов.

                     merge() это вспомогательная функция, созданная, чтобы помочь объединить эти 
                             разбитые списки в упорядоченные списки комбинаций.
------------------------------------------------------------------------------------------------------------------------
                                                                            БЫСТРАЯ СОРТИРОВКА
                                           Quicksort — классический алгоритм сортировки с отличным средним временем выполнения.
                                           Быстрая сортировка — это эффективный способ сортировки списка значений путем
                                           разделения списка на более мелкие вложенные списки на основе сравнения с одним «основным» элементом.
                                           Наш алгоритм будет рекурсивным, поэтому у нас будет базовый случай и индуктивный шаг, 
                                           приближающий нас к базовому случаю.
 
                                            Мы также отсортируем наш список на месте, чтобы сделать его максимально эффективным.
                                            Указатели — это индексы, которые отслеживают часть списка.
                                            Мы будем использовать два указателя start и end отслеживать подсписки в нашем алгоритме.

                                            Мы будем передавать один и тот же список в качестве аргумента для каждого рекурсивного вызова,
                                            , но start будем end отмечать, какую часть списка мы рассматриваем.

from random import randrange, shuffle       Наш базовый случай — это когда список от start до end содержит один или ноль элементов.
                                            увеличьте startна единицу и рекурсивно вызовите quicksortс помощью list, start и end.
def quicksort(list, start, end):
  
  if start >= end:
    return
  print("Running quicksort on {0}".format(list[start: end + 1]))
                                                                    мы заменим этот случайный элемент последним элементом списка, 
  pivot_idx = randrange(start, end + 1)                             чтобы наш код постоянно знал, где найти опорную точку.
  pivot_element = list[pivot_idx]                                    Мы импортировали randrange()функцию, Используйте эту функцию для создания переменной pivot_idx,
  print("Selected pivot {0}".format(pivot_element))                  случайного индекса между start и end.
                                                                     еще однo переменную pivot_element и используйте ее pivot_idx для получения значения,
  list[end], list[pivot_idx] = list[pivot_idx], list[end]               который был передан в качестве аргумента.
                                                                     Поменяйте местами end элемент списка с элементом , pivot_idx чтобы мы знали,
  less_than_pointer = start                                           что опорный элемент всегда будет находиться в конце списка.
                                                                         lesser_than_pointerи назначьте ее началу списка.
  for i in range(start, end):
    if list[i] < pivot_element:                                               Нам нужно разделить наш список на два подсписка,
      print("Swapping {0} with {1}".format(list[i], list[less_than_pointer]))  idx меньше чем pivot_element.
      list[i], list[less_than_pointer] = list[less_than_pointer], list[i]       Используйте параллельное присваивание, чтобы поменять местами 
                                                                                  значения в lesser_than_pointerи idx.
      less_than_pointer += 1                                                     Увеличить lesser_than_pointer
                                                                               После завершения цикла используйте параллельное присваивание, чтобы поменять
  list[end], list[less_than_pointer] = list[less_than_pointer], list[end] 
                                                                                После того, как мы прошлись по списку, мы меняем опорный элемент на элемент,
                                                                                расположенный по адресу lesser_than_pointer.

                                                                                местами опорный элемент со значением, расположенным в lesser_than_pointer.
  print("{0} successfully partitioned".format(list[start: end + 1]))
 
                                                                              мы будем рекурсивно вызывать быструю сортировку и передавать эти обновленные указатели, 
                                                                              чтобы пометить различные вложенные списки.

                                                               рекурсивно вызвав быструю сортировку в левом и правом подсписках.

  quicksort(list, start, less_than_pointer - 1)               Левый подсписок отмечен от startдо less_than_pointer - 1.
  quicksort(list, less_than_pointer + 1, end)                 Правый подсписок отмечен от less_than_pointer + 1 до end.


                                                                      Разделив список на два подсписка, мы повторяем процесс для обеих половин,
                                                                      пока не будут выполнены базовые случаи.
  
list = [5,3,1,7,4,6,2,8]
shuffle(list)
print("PRE SORT: ", list)
print(quicksort(list, 0, len(list) -1))
print("POST SORT: ", list)

------------------------------------------------------------------------------------------------------------------------
                                 Пузырьковая сортировка — это алгоритм сортировки списка путем многократного перестановки соседних элементов.
                                                             Он имеет время выполнения O(n^2).

nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]                      Алгоритм пузырьковой сортировки работает, сравнивая пару
print("PRE SORT: {0}".format(nums))                     соседних элементов и сдвигая больший из двух вправо.

def swap(arr, index_1, index_2):                       меняет местами элементы до тех пор, пока самый большой элемент
  temp = arr[index_1]                                   в списке не будет помещен в самый большой индекс. 
  arr[index_1] = arr[index_2]                           temp установите значение index_1  arr равным значению at index_2 arr.
  arr[index_2] = temp                                   Затем установите значение, расположенное в, index_2 равным temp.

def bubble_sort_unoptimized(arr):                       У нас будет две петли:

                                                         Один цикл будет перебирать каждый элемент в списке.
  iteration_count = 0                                    Внутри второго цикла мы возьмем индекс цикла и сравним элемент по этому индексу с элементом по
  for el in arr:                                         следующему индексу. Если они не в порядке, мы произведем обмен!
    for index in range(len(arr) - 1):                     проверьте, является  значение в arr значением в arr[index] > arr[index + 1]
      iteration_count += 1                               Если это так, используйте swap() и передайте arr, index и index + 1 в качестве аргументов.
      if arr[index] > arr[index + 1]:                    Создайте еще один цикл, который повторяется для каждого элемента в arr
        swap(arr, index, index + 1)                      Запустите код еще раз, ваш список должен быть отсортирован!

  print("PRE-OPTIMIZED ITERATION COUNT: {0}".format(iteration_count))

def bubble_sort(arr):
  iteration_count = 0
  for i in range(len(arr)):
    # iterate through unplaced elements
    for idx in range(len(arr) - i - 1):
      iteration_count += 1
      if arr[idx] > arr[idx + 1]:
        # replacement for swap function
        arr[idx], arr[idx + 1] = arr[idx + 1], arr[idx]
        
  print("POST-OPTIMIZED ITERATION COUNT: {0}".format(iteration_count))

bubble_sort_unoptimized(nums.copy())
bubble_sort(nums)
print("POST SORT: {0}".format(nums))
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                         Производительность сортировки слиянием      

      Сортировка слиянием была уникальной для своего времени тем, что лучшая, 
      худшая и средняя временная сложность одинаковы: Θ(N*log(N))
        Это означает, что наихудшая пространственная сложность сортировки слиянием равна O(N).

------------------------------------------------------------------------------------------------------------------------------------------------------
def pre_order_to_list(bst, nums):
  # Enter code below...
  # base case when bst is none, nothing to add
  if bst is None:
    return 

  # add the root to nums
  nums.append(bst.value)

  # recursive calls to left and right children
  pre_order_to_list(bst.left, nums)

  pre_order_to_list(bst.right, nums)
---------------------------------------------------------------------------------------------------
def recurse(n):
  # DO NOT REMOVE 
  recurse.count+=1
  recurse.call_stack.append(n)

  # base case
  if n <= 1:
    # do nothing
    return
  
  # inductive step
  
  # even n
  if n % 2 == 0:
    return recurse(n-3)
  else:
    # odd n
    return recurse(n+1)

-----------------------------------------------------------------------------------------------------------------------------------------------
                                                                         ПОРАЗРЯДНАЯ СОРТИРОВКА: PYTHON

                                                         Нашим первым шагом будет нахождение max_exponent,
                                                         которое представляет собой количество цифр, длиннее самого большого числа.
                                                         Мы найдем наибольшее число, приведем его к строке и возьмем длину этой строки.


                                                         нам нужно найти самое длинное число (max_exponent)

def radix_sort(to_be_sorted):                             Сначала приведите maximum_valueк строке.
  maximum_value = max(to_be_sorted)                       Затем возьмите len()эту строку.
  max_exponent = len(str(maximum_value))                  Затем присвойте это len()переменной с именем max_exponent.
  being_sorted = to_be_sorted[:]                          Затем вернитесь max_exponent.

                                                          цикле for, она будет подсчитывать текущую степень, на которую мы смотрим, для каждого числа.
                                                          Поскольку exponentон имеет нулевой индекс, наш
                                                          position всегда будет на единицу больше, чем файл exponent. Присвойте ему значение exponent + 1.

  for exponent in range(max_exponent):                    По характеру сортировки по основанию нам нужно стирать и перезаписывать наш
    position = exponent + 1                               выходной список несколько раз.
                                                           поскольку мы собираемся индексировать строку в обратном порядке, оно должно быть отрицательным!
                                                          Установить index = -position.

    index = -position                                      Поскольку существует 10 различных значений (то есть от 0 до 9), которые может иметь
                                                          позиция, нам нужно создать десять разных сегментов, чтобы поместить в них каждое число.
    digits = [[] for i in range(10)]                      Создайте список из десяти пустых списков и присвойте результат переменной
                                                           с именем digits.
    for number in being_sorted:                           Нам нужно будет перебрать being_sorted
      number_as_a_string = str(number)                   Теперь преобразуйте numberв строку и сохраните ее как number_as_a_string.
      try:                                               Сохраните последний элемент number_as_a_string в переменную digit.
        digit = number_as_a_string[index]                Здесь мы будем отображать список, сначала он просто вернет список, отсортированный так, 
      except IndexError:                                 что будут отсортированы только единицы.
        digit = 0
      digit = int(digit)                                 digit значение at number_as_a_string index, index теперь нам нужно обернуть это определение в try блок.

      digits[digit].append(number)
                                                         Обработайте исключение, добавив except IndexError блок, в данном случае присвоив цифре значение 0.
    being_sorted = []
    for numeral in digits:                               Назовите каждый из этих списков numeral, потому что каждый из них соответствует одной конкретной
      being_sorted.extend(numeral)                       цифре от 0 до 9..extend()метод (который добавляет все элементы списка вместо
                                                         добавления самого списка), чтобы добавить элементы numeralв being_sorted.
  return being_sorted

unsorted_list = [830, 921, 163, 373, 961, 559, 89, 199, 535, 959, 40, 641]
print(radix_sort(unsorted_list))

                                              Мы создали алгоритм, который:

Принимает числа в списке ввода.
Проходит через каждую цифру в этих числах, от младшего к старшему.
Смотрит на значения этих цифр.
Разбивает список ввода в соответствии с этими цифрами.
Визуализирует результаты этого группирования.
Повторяет этот процесс до тех пор, пока список не будет отсортирован.

-----------------------------------------------------------------------------------------------------------------------------------------------------
                                                                    ГРАФИКИ: PYTHON

class Vertex:                                                     Этот класс отвечает за хранение информации об отдельных вершинах нашего графа. 
  def __init__(self, value):
    self.value = value
    self.edges = {}    
                                                                 .get_edges()это удобный метод, который дает нам список имен вершин, связанных с self.

  def add_edge(self, vertex, weight=0):
                                                                 Используйте vertex в качестве ключа внутри self.edges и установите его на True.
    self.edges[vertex] = weight
                                                                 назначения forty_second_street.value в качестве края grand_central.

  def get_edges(self):
    return list(self.edges.keys())
                           
                                                                 

                                                          Мы создали класс для хранения информации и связей между отдельными вершинами,
                                                           но нам нужен еще один класс, который отслеживает общую картину.


class Graph:                                                                 Наш Graph класс будет отслеживать все вершины 
  def __init__(self, directed = False):
    self.graph_dict = {}                                                     directed должен по умолчанию быть False.
    self.directed = directed                                                 Мы хотели бы, чтобы наш Graphкласс мог устанавливать ребра между сохраненными вершинами. 
                                                                             Хорошая новость заключается в том, что в нашем Vertex классе уже есть .add_edge()метод,
  def add_vertex(self, vertex):
    self.graph_dict[vertex.value] = vertex                                   Чтобы сделать этот класс максимально гибким, мы добавим weight аргумент по умолчанию 
                                                                             .add_edge()в классы Graph и Vertex.
                                                                             Взвешенные ребра позволяют нам строить графы,  
                                                                            
 
  def add_edge(self, from_vertex, to_vertex, weight = 0):
    self.graph_dict[from_vertex.value].add_edge(to_vertex.value, weight)       Ключ в self.graph_dict с from_vertex.value
    if not self.directed:                                                     Вызов .add_edge значения словаря и передача to_vertex.value в качестве аргумента

      self.graph_dict[to_vertex.value].add_edge(from_vertex.value, weight)     В .add_edge()методе graph.py , если граф не направлен, делаем следующее:
                                                                               Ключ в self.graph_dict  с to_vertex.value
                                                                               Вызов .add_edge значения словаря и передача from_vertex.valueв качестве аргумента
  def find_path(self, start_vertex, end_vertex):
    start = [start_vertex]                                                     Наш Graph класс должен определить, существует ли путь между двумя вершинами.
    seen = {}                                                                  Мы будем использовать этот список для отслеживания вершин при поиске.
    while len(start) > 0:                                                       while пока start в списке есть элементы.
      current_vertex = start.pop(0)                                            current_vertexи установите ее равной первому элементу в start.
      seen[current_vertex] = True                                              удалить этот элемент из start, иначе цикл не завершится .
      print("Visiting " + current_vertex)                                      Если current_vertex совпадает с end_vertex аргументом, значит, 
      if current_vertex == end_vertex:                                         вы нашли путь и можете return True.
        return True
      else:                                                                    В противном случае нам нужно продолжать поиски.
        vertices_to_visit = set(self.graph_dict[current_vertex].edges.keys())  Создайте новую переменную vertex и назначьте ее экземпляру вершины, используя
        start += [vertex for vertex in vertices_to_visit if vertex not in seen]        current_vertex ключ в self.graph_dict.
    return False                                                               Звоните . .get_edges()_ vertexПрисвойте результат переменной с именем next_vertices.
                                                                               Добавьте next_vertices список в конец start.

                                                                               Мы будем использовать словарь, чтобы отслеживать, какие станции мы посетили
                                                                               Это не позволит нашим пассажирам ездить по кругу.
                                                                               Замените закомментированный код рядом start с seen переменной,
                                                                               которая начинается как пустой словарь.
 script.py
---------------
from random import randrange
from graph import Graph
from vertex import Vertex

def print_graph(graph):
  for vertex in graph.graph_dict:
    print("")
    print(vertex + " connected to")
    vertex_neighbors = graph.graph_dict[vertex].edges
    if len(vertex_neighbors) == 0:
      print("No edges!")
    for adjacent_vertex in vertex_neighbors:
      print("=> " + adjacent_vertex)


def build_graph(directed):
  g = Graph(directed)
  vertices = []
  for val in ['a', 'b', 'c', 'd', 'e', 'f', 'g']:
    vertex = Vertex(val)
    vertices.append(vertex)
    g.add_vertex(vertex)

  for v in range(len(vertices)):
    v_idx = randrange(0, len(vertices) - 1)
    v1 = vertices[v_idx]
    v_idx = randrange(0, len(vertices) - 1)
    v2 = vertices[v_idx]
    g.add_edge(v1, v2, randrange(1, 10))

  print_graph(g)

build_graph(False)




  Мы реализовали надежную структуру данных графа в Python. Наши два класса Vertex и Graph
  способны отображать типичные вариации графов, встречающиеся во многих различных алгоритмах.
                     Vertex:

Использует словарь в качестве списка смежности для хранения связанных вершин.
Имена подключенных вершин являются ключами, а веса ребер — значениями.
Имеет методы для добавления ребер и возврата списка связанных вершин.
  
                      Graph:

Может быть инициализирован как ориентированный граф, в котором ребра заданы в одном направлении.
Сохраняет каждую вершину в словаре
Данные вершины — это ключ, а экземпляр вершины — это значение.
Имеет методы для добавления вершин, ребер между вершинами и определения наличия пути между двумя вершинами.
------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                  Обзор ключевых терминов

Графы являются важной структурой данных в информатике для моделирования сетей. Давайте рассмотрим некоторые ключевые термины:
 
     vertex: узел в графе.

     edge: соединение между двумя вершинами.

     adjacent: когда между вершинами существует ребро.

     path: последовательность одного или нескольких ребер между вершинами.

     disconnected: Граф, в котором по крайней мере две вершины не имеют пути, соединяющего их.

     weighted: График, на котором ребра имеют связанную стоимость.

     directed: График, в котором перемещение между вершинами может быть ограничено одним направлением.

     cycle: Путь, который начинается и заканчивается в одной вершине.

     adjacency matrix: графическое представление, где вершинами являются как строки, так и столбцы. Каждая ячейка представляет возможное ребро.

     adjacency list: графическое представление, в котором каждая вершина имеет список всех вершин, с которыми она имеет общее ребро.
----------------------------------------------------------------------------------------------------------------------------------------------
                                                                               ГРАФИКИ: PYTHON
class Vertex:
  def __init__(self, value):
    self.value = value
    self.edges = {}

  def add_edge(self, vertex, weight = 0):
    self.edges[vertex] = weight

  def get_edges(self):
    return list(self.edges.keys())
---------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                 Графический поиск Python: обзор


                                   поиск в глубину с использованием рекурсии
                                   поиск в ширину с использованием очереди

DFS, которая использует либо рекурсию, либо структуру данных стека, полезна для определения того, существует ли путь между двумя точками.

BFS, которая обычно опирается на структуру данных очереди, помогает найти кратчайший путь между двумя точками.

Существует три распространенных порядка обхода, которые вы можете применить с DFS для создания списка всех значений в графе:
 предварительный порядок, пост-порядок и обратный порядок после.

асимптотическая запись описывает время выполнения алгоритмов поиска по графу --- O(vertices + edges)


    Во-первых, вы создадите алгоритм поиска в глубину, используя рекурсию, который поможет вам определить,
    существует ли путь, и, если да, предоставит вам первый возможный путь, который найдет функция.

    Затем вы создадите функцию поиска в ширину , которая приведет вас к кратчайшему пути между двумя точками.
     следующие параметры в качестве параметров:

     graph(это график, который мы передаем)
     current_vertex(передаваемое значение будет начальной вершиной)
     target_value(значение, которое мы ищем)
     visited(список для сбора пути нашего алгоритма) Дайте visited значение по умолчанию None. 



def dfs(graph, current_vertex, target_value, visited = None):      Узнать, существует ли путь между вершинами и вернуться True или False соответственно?
  if visited is None:                                              Вернуть расстояние между источником и пунктом назначения, Вернуть сам путь?
    visited = []                                                   Создайте if оператор, который возвращает visited,когда current_vertex совпадает с target_value.
  visited.append(current_vertex)
  if current_vertex is target_value:                                 построить рекурсивный кейс для вашей функции…
    return visited                                                  for, чтобы проверить каждый neighbor из current_vertex на нашем графике.
                                                                    не хотим повторно посещать вершины добавьте ifздесь пункт, который гарантирует, что neighbor они
  for neighbor in graph[current_vertex]:                            добавлены в visited.

    if neighbor not in visited:                                     graph(график не изменился)
      path = dfs(graph, neighbor, target_value, visited)            neighbor(это новое current_vertexв вызове функции)
      if path:                                                      target_value(значение, которое мы все еще ищем)
        return path                                                 visited(теперь список хотя бы одного значения вершины)
                                                                    Проверьте, path существует ли. Если что, верните path.


def bfs(graph, start_vertex, target_value):                        Поиск в ширину: убери мою ширину  нас интересует только то, посещается ли вершина или нет,
  path = [start_vertex]                                            bfs_queueи установите ее равной списку, содержащему vertex_and_path
  vertex_and_path = [start_vertex, path]                           будем использовать это для отслеживания каждой комбинации пути вершины.
  bfs_queue = [vertex_and_path]
  visited = set()
  while bfs_queue:                                                 while цикл, который выполняется до тех пор, пока что-то находится в bfs_queue.
    current_vertex, path = bfs_queue.pop(0)
    visited.add(current_vertex)                                    внутри while цикла добавьте current_vertex в набор посещенных узлов.
    for neighbor in graph[current_vertex]:                         Настройте for цикл для перебора каждой neighbor в этом наборе соседних вершин.
      if neighbor not in visited:                                  if условие для случая, neighbor когда target_value.
        if neighbor is target_value:                               Если это так, верните path с neighbor добавлением к нему.
          return path + [neighbor]
        else:                                                      Создайте else условие для обработки случая, когда нам нужно продолжать поиск,
          bfs_queue.append([neighbor, path + [neighbor]])          потому что neighbor это не файл target_value.
 
some_hazardous_graph = {
    'lava': set(['sharks', 'piranhas']),
    'sharks': set(['piranhas', 'bees']),
    'piranhas': set(['bees']),
    'bees': set(['lasers']),
    'lasers': set([])
  }

print(bfs(some_hazardous_graph, 'sharks', 'bees'))
print(dfs(some_hazardous_graph, 'sharks', 'bees'))
--------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                         Жадные алгоритмы

Жадный алгоритм — это алгоритм, используемый в задачах оптимизации ,целью которых является поиск оптимального решения (максимального или
минимального) среди всех возможных решений.Например, поиск кратчайшего пути между двумя точками на карте — это задача оптимизации,
целью которой является минимизация результата.

Жадный алгоритм создает решение задачи оптимизации, принимая наилучшее решение на каждом этапе.
Жадные алгоритмы просты и эффективны, но НЕ всегда правильны.
Чтобы жадный алгоритм работал, задача должна удовлетворять:
Оптимальное свойство основания
Жадная собственность

--------------------------------------------------------------------------------------------------------------------------------------------------------
                                                             АЛГОРИТМ ДЕЙКСТРЫ: PYTHON

Алгоритм Дейкстры — это алгоритм поиска всех кратчайших расстояний между начальной вершиной и остальными вершинами графа.
Алгоритм работает, отслеживая все расстояния и обновляя расстояния по мере выполнения поиска в ширину.
Алгоритм Дейкстры работает за O((E+V)log V).

    Один из способов представления графа — список смежности с использованием словаря Python.

    Взгляните на следующий граф, представленный списком смежности:              


from heapq import heappop, heappush
from math import inf

graph = {                                         graph имеет 5 вершин: 'A', 'B', 'C', 'D', 'E'.
        'A': [('B', 10), ('C', 3)],               Есть путь из 'B'в 'C'со стоимостью 3 и путь из 'B' в 'D'со стоимостью 2.
        'C': [('D', 2)],                          Существует путь из 'C'в 'D'со стоимостью 2.
        'D': [('E', 10)],                         Существует путь из 'D'в 'E'со стоимостью 10.
        'E': [('A', 7)],                          Существует путь из 'E'в 'A'со стоимостью 7.
        'B': [('C', 3), ('D', 2)]                 Существует путь из 'B'в 'C' ,из 'B'- 'D' со стоимостью 3, 2.
    } 
                                                 Этот heapqметод имеет два важных метода, которые мы будем использовать в алгоритме Дейкстры: heappushи heappop.
                                                 heappush добавит значение в кучу и соответствующим образом отрегулирует кучу
                                                 heappop удалит и вернет наименьшее значение из кучи

                                                 Чтобы отслеживать все расстояния для алгоритма Дейкстры мы будем использовать кучу! Использование кучи позволит
                                                 эффективно удалить минимум из кучи. В python, есть библиотека heapq.
  
                                                 Мы можем добавить значения в эту кучу следующим образом:
                                            
                                                  heapq.heappush(heap, (1, 'B'))
                                                  heapq.heappush(heap, (-4, 'C'))
                                               
                                                  Мы можем удалить наименьшее значение в куче следующим образом:
                    
                                                 value, letter  = heapq.heappop(heap)      
                                                  value будет равно -4, и letter будет равно 'C'.

   Первая часть алгоритма посвящена инициализации! Вот что нам нужно сделать:

Задайте функцию с помощью start вершины и графика.
Создайте distances словарь, который в конечном итоге сопоставит вершины с их расстоянием от начальной вершины.
Назначьте начальной вершине расстояние 0.
Назначьте каждой другой вершине расстояние infinity.
Настройте vertices_to_exploreсписок минимальной кучи, который отслеживает соседние вершины, оставшиеся для исследования.
После инициализации этих переменных мы можем пройти по графику и обновить расстояния!





def dijkstras(graph, start):                      Внутри тела функции определите distances как пустой словарь. Мы будем отслеживать все кратчайшие расстояния в этом
  distances = {}                                  Вернуться distances. Мы построим остальную часть тела функции между этими двумя строками.
  
  for vertex in graph:                            Переберите каждый vertex вход graph и установите его соответствующее значение distances равным inf.
    distances[vertex] = inf
                                                  Установите distances[start]равным, 0 потому что
  distances[start] = 0                            расстояние от начальной вершины до начальной вершины равно 0.
  vertices_to_explore = [(0, start)]              назначьте ей список с одним элементом внутри: кортеж из 0и start.
                                                  Этот кортеж представляет start вершину в списке минимальной кучи.
  while vertices_to_explore:
    current_distance, current_vertex = heappop(vertices_to_explore)    Внутри нашего while цикла мы будем перебирать соседние вершины current_vertexи добавлять каждого
                                                                       соседа (и его расстояние от start) в vertices_to_explore минимальную кучу.
    for neighbor, edge_weight in graph[current_vertex]:                Определить neighbor расстояние от start.
      new_distance = current_distance + edge_weight                    Убедитесь, что новое найденное расстояние для neighborменьше расстояния, 
                                                                       установленного в настоящее время для distances[neighbor].
      if new_distance < distances[neighbor]:                           Обновите distances[neighbor], если новое расстояние меньше
        distances[neighbor] = new_distance                             текущего записанного расстояния.
        heappush(vertices_to_explore, (new_distance, neighbor))        Добавьте neighbor и его расстояние до vertices_to_explore мин-кучи.
        
  return distances
        
distances_from_d = dijkstras(graph, 'D')
print("\n\nShortest Distances: {0}".format(distances_from_d))
----------------------------------------------------------------------------------------------------------------------------------------
                                                                                A* АЛГОРИТМ: PYTHON

Алгоритм A* является модификацией алгоритма Дейкстры. A* работает, имея как начальную вершину, так и целевую вершину.
Алгоритм вычисляет оценочное расстояние или эвристику для всех возможных путей между начальной и конечной вершинами, а затем выбирает кратчайший из них.
Поиск пути — это алгоритмическая концепция поиска кратчайшего пути между двумя точками в графе.
В этом курсе рассматриваются два типа методов поиска пути: алгоритм Джикстры и алгоритм A*.

                                            Обзор А*
Алгоритм A* — это жадный алгоритм поиска графа, оптимизирующий поиск целевой вершины.
A* — это модификация Дейкстры, выполненная путем добавления предполагаемого расстояния каждой вершины до целевой вершины при поиске.
Мы можем изменить Дейкстру и превратить его в A *, изменив следующее:
Добавление цели для поиска.
Сбор возможных оптимальных путей и определение единственного кратчайшего пути.
Реализация эвристики, определяющей вероятное оставшееся расстояние.
Время выполнения A* равно O(b d ), где b— коэффициент ветвления графа, а d— глубина целевой вершины от начальной вершины.
A* — это вводный взгляд на искусственный интеллект.

  Чтобы создать реализацию A* на Python, вы начнете с алгоритма Дейкстры, а затем будете строить его
  Вам нужно будет внести всего несколько важных изменений:

Включите цель для поиска, чтобы найти. Больше не нужно искать во всех направлениях для всех пунктов назначения.

Собери и верни кратчайший путь. Словарь расстояний — это круто и все такое, но задача A* — доставить вас к месту назначения и рассказать, как туда добраться.

Создайте эвристику, которая вычисляет расчетное расстояние между двумя точками. Это ключевой момент различия 
между Дейкстрой и А*; A* имеет реальное чувство направления.




from math import inf, sqrt
from heapq import heappop, heappush
from manhattan_graph import manhattan_graph, penn_station, grand_central_station
from euclidean_graph import euclidean_graph, bengaluru, jaipur

# Manhattan Heuristic:                                        Переименуйте ВСЕ экземпляры distances внутри a_star()в paths_and_distances. Мы также будем
def heuristic(start, target):                                 использовать эту переменную для отслеживания каждого пути.
  x_distance = abs(start.position[0] - target.position[0])    Для получения эвристической оценки нам необходимо:
  y_distance = abs(start.position[1] - target.position[1])    Измерьте расстояние между x позиционными значениями двух вершин 
  return x_distance + y_distance                               и между их y позиционными значениями.
                                                              Верните сумму расстояния x и y расстояния вместе.
                                                              В теле функции создайте переменную x_distance и установите ее равной
                                                              абсолютному значению целевого x значения, вычтенному из start значения x.
                                                              y_distanceТаким же образом создайте переменную .

                                                              Перейти к строке, a_star()где new_distance определяется. 
def a_star(graph, start, target):
  print("Starting A* algorithm!")
  count = 0
  paths_and_distances = {}
  for vertex in graph:
    paths_and_distances[vertex] = [inf, [start.name]]        inf(Это будет расстояние.)список, содержащий start.name(Это будет путь, начинающийся с первой вершины.)
  
  paths_and_distances[start][0] = 0                           paths_and_distances[some_variable_name][0].Таким образом, вы устанавливаете и 
                                                              получаете расстояние только для этих экземпляров.
  vertices_to_explore = [(0, start)]
  while vertices_to_explore and paths_and_distances[target][0] == inf:
    current_distance, current_vertex = heappop(vertices_to_explore)
    for neighbor, edge_weight in graph[current_vertex]:
      new_distance = current_distance + edge_weight + heuristic(neighbor, target)   -->Установить new_distance равным сумме:current_distance+edge_wight+heuristic
      new_path = paths_and_distances[current_vertex][1] + [neighbor.name]              (neighor, target)
      
      if new_distance < paths_and_distances[neighbor][0]:
        paths_and_distances[neighbor][0] = new_distance        Добавьте новую строку ниже, чтобы установить соответствующий путь равным new_path.
        paths_and_distances[neighbor][1] = new_path
        heappush(vertices_to_explore, (new_distance, neighbor))
        count += 1
        print("\nAt " + vertices_to_explore[0][1].name)
        
  print("Found a path from {0} to {1} in {2} steps: ".format(start.name, target.name, count), paths_and_distances[target][1])
  
  return paths_and_distances[target][1]                          оператор возврата, чтобы он возвращал путь к файлу target.
----------------------------------------------------------------------------------------------------------------------------------------------------------
                                                            Алгоритмы грубой силы

Алгоритм грубой силы решает проблему, перебирая все возможные варианты, пока либо не будет найдено решение, либо не будут исчерпаны все возможности (нет решения).
Временная сложность алгоритма грубой силы часто пропорциональна размеру входных данных.
Плюсы грубой силы:
Легче реализовать, чем более оптимизированные алгоритмы
Простой, последовательный и без ошибок
Некоторые алгоритмы грубой силы (например, пузырьковая сортировка) требуют меньше памяти, чем их более оптимизированные аналоги.
Минусы грубой силы:
Медленное время выполнения, когда есть много возможных вариантов для вычисления
Неприменим для реальных задач

-------------------------------------------------------------------------------------------------------------------------------------------
                                                            ТЕХНИЧЕСКИЕ ИНТЕРВЬЮ: ИНТЕРАКТИВНАЯ ДОСКА
    Шаги:

    Уточнить проблему
    Создать входы
    Обрисуйте решение
    Закодируйте решение
    Протестируйте решение
    Проанализируйте решение
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                               динамическое программирование на Python


   Динамическое программирование — это метод программирования, используемый для более эффективного решения рекурсивных задач.
   
    Мемоизация
    Мемоизация — это специальная форма кэширования, используемая для хранения результата вызова функции. 
    Мемоизация — отличная техника, которую можно использовать вместе с рекурсией. 
    даже сохранить между вызовами функций, если она используется для общих вычислений в программе.
    Динамическое программирование и мемоизация — отличные методы для разбиения сложных рекурсивных задач на более мелкие фрагменты.
    Они особенно полезны при решении задач, связанных с комбинациями.



memo = {}

def fibonacci(num):                                               посмотрим на общее количество вызовов функций. 
  answer = None                                                   Раньше для вычисления 10-го числа требовалось 177 вызовов функций.
  # Write your code here                                          Теперь должно быть только 19.
  if num in memo:
    answer = memo[num]
  elif num == 0 or num == 1:
    answer = num
  else:
    answer = fibonacci(num-1) + fibonacci(num-2)
    memo[num] = answer
  return answer
print(fibonacci(20))
print(fibonacci(200))
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                         Сбор дождевой воды

В задаче улавливания дождевой воды вас просят рассчитать, сколько дождевой воды будет захвачено пустыми местами на гистограмме
(диаграмме, состоящей из ряда столбцов). Рассмотрим следующую гистограмму:

Наивное решение проблемы состоит в следующем:

Обход каждого элемента в массиве
Найдите самую высокую левую границу для этого индекса
Найдите самую высокую правую границу для этого индекса
Возьмите меньшее из этих двух значений
Вычтите высоту этого индекса из этого минимума
Добавьте разницу к общему количеству воды.

В Python это решение выглядит так:

def naive_solution(heights):
  total_water = 0
  for i in range(1, len(heights) - 1):
    left_bound = 0
    right_bound = 0
    for j in range(i+1):
      left_bound = max(left_bound, heights[j])
 
    for j in range(i, len(heights)):
      right_bound = max(right_bound, heights[j])
 
    total_water += min(left_bound, right_bound) - heights[i]

Хотя это функциональное решение, оно требует вложенных for циклов, а это означает, что оно имеет большое время выполнения O, равное O(n^2).

                                                         Оптимизированное решение
 проблему можно решить вовремя O(n), используя два указателя. 
 Указатели будут начинаться с каждого конца массива и двигаться друг к другу.

def efficient_solution(heights):                                   Мы начнем с создания следующих переменных:
  total_water = 0                                                  left_pointer и right_pointer будут начинаться в начале и в конце массива
  left_pointer = 0                                                 соответственно и двигаться навстречу друг другу, пока не встретятся.
  right_pointer = len(heights) - 1
  left_bound = 0
  right_bound = 0                                                  создали оптимизированное решение проблемы улавливания дождевой воды
                                                                   Это решение имеет линейную временную сложность, потому что оно проходит 
                                                                   через массив только один раз.
  while left_pointer < right_pointer:                              имеют постоянную пространственную сложность O(1).
    if heights[left_pointer] <= heights[right_pointer]:
      left_bound = max(heights[left_pointer], left_bound)
      total_water += left_bound - heights[left_pointer]
      left_pointer += 1
    else:
      right_bound = max(heights[right_pointer], right_bound)
      total_water += right_bound - heights[right_pointer]
      right_pointer -= 1

  return total_water


test_array = [4, 2, 1, 3, 0, 1, 2]
print(efficient_solution(test_array))
                                                     решение имеют постоянную пространственную сложность O(1).
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                          Проблема рюкзака
Подходы рекурсивного и динамического программирования к классической задаче о рюкзаке в Python.
Первым шагом к решению этой проблемы является понимание задействованных параметров. Вам будет предоставлено:

общий вес, который вы можете нести ( weight_cap)
веса всех элементов массива ( weights)
значения всех элементов массива ( values)
Ваша функция должна возвращать максимальное значение, которое вы сможете унести.
                                                Рекурсивное решение.
Есть три возможности для каждого вызова функции:

weight_cap или i равны нулю, что означает, что рюкзак не может выдержать веса 
или больше не на что смотреть. В любом случае мы возвращаемся 0.

Вес элемента, который мы рассматриваем, превышает weight_cap, и в этом случае мы 
просто идем дальше, вызывая функцию для следующего элемента.

i Если ни одно из вышеперечисленных не верно, это означает, что мы должны рассмотреть вопрос о том, 
следует ли включать элемент, в котором мы находимся ( ), в оптимальное решение.

Шаги 1 и 2 выше могут быть решены следующим образом:

def recursive_knapsack(weight_cap, weights, values, i):
  
  if weight_cap == 0 or i == 0:
    return 0
  
  elif weights[i - 1] > weight_cap:
    return recursive_knapsack(weight_cap, weights, values, i - 1)

Введите код, чтобы решить шаг 3 и завершить recursive_knapsack()функцию.

def recursive_knapsack(weight_cap, weights, values, i):
  if weight_cap == 0 or i == 0:
    return 0
  elif weights[i - 1] > weight_cap:
    return recursive_knapsack(weight_cap, weights, values, i - 1)
  else:
    include_item = values[i - 1] + recursive_knapsack(weight_cap - weights[i - 1], weights, values, i - 1);
 
    exclude_item = recursive_knapsack(weight_cap, weights, values, i - 1);
 
    return max(include_item, exclude_item)

   Хотя это рекурсивное решение работает, оно имеет большое время выполнения O — O(2^n). 

                                    Задача о рюкзаке подходит для динамического программирования, потому
                                    что мемоизация позволит нам хранить информацию, а не повторять вызовы.
                                    динамического программирования к задаче о рюкзаке. Эта версия имеет большое время выполнения O по O(n * weight_cap)


def dynamic_knapsack(weight_cap, weights, values):
  rows = len(weights) + 1
  cols = weight_cap + 1                                              matrix является максимальным значением, которое мы
  matrix = [ [] for x in range(rows) ]                               можем принять, учитывая грузоподъемность и количество элементов,
                                                                     которые мы видели для этой подзадачи. 
  for index in range(rows):
    matrix[index] = [ -1 for y in range(cols) ]

    for weight in range(cols):
      if index == 0 or weight == 0:
        matrix[index][weight] = 0
      elif weights[index - 1] <= weight:
        include_item = values[index - 1] + matrix[index - 1][weight - weights[index - 1]]
        exclude_item = matrix[index - 1][weight]
        matrix[index][weight] = max(include_item, exclude_item)
      else:
        matrix[index][weight] = matrix[index - 1][weight]
  return matrix[rows-1][weight_cap]


weight_cap = 50
weights = [31, 10, 20, 19, 4, 3, 6]
values = [70, 20, 39, 37, 7, 5, 10]
print(dynamic_knapsack(weight_cap, weights, values))                 время выполнения  O(n * weight_cap)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                      Эратосфена для поиска простых чисел в Python.

Решето Эратосфена — один из старейших известных алгоритмов, и он до сих пор полезен для получения простых чисел! 


Реализуйте фазу неосновной маркировки Решета Эратосфена. Для каждого числа от 2 до limit + 1 проверьте, не было ли оно уже отмечено как не
простое. Если это не так, пометьте все его кратные числа как непростые.

Завершите find_true_indices()функцию. Он должен иметь один параметр (массив) и возвращать true_indicesновый массив всех истинных индексов во входных данных.

def sieve_of_eratosthenes(limit):
  true_indices = []

  if (limit <= 1):
    return true_indices
  output = [True] * (limit+1)
  output[0] = False
  output[1] = False
  for i in range(2, limit+1):
    if (output[i] == True):
      j = i*2
      while j <= limit:
        output[j] = False
        j += i

  output_with_indices = list(enumerate(output))
  true_indices = [index for (index,value) in output_with_indices if value == True]
  return true_indices


primes = sieve_of_eratosthenes(91)
print(primes) # should return [2, 3, 5, 7, 11, 13]

                                                           Ниже приведен код нашего сита, включая оптимизации:


import math
 
def sieve_of_eratosthenes (limit):
  
  if (limit <= 1):
    return []
  output = [True] * (limit+1)
  output[0] = False
  output[1] = False
  for i in range(2, math.floor(math.sqrt(limit))):
    if (output[i] == True):
      j = i ** 2    # initialize j to square of i
      while j <= limit:
        output[j] = False
        j += i
  output_with_indices = list(enumerate(output))
  trues = [index for (index,value) in output_with_indices if value == True]
  return trues
 
primes = sieve_of_eratosthenes(20)
print(primes) # return [2, 3, 5, 7, 11, 13, 17, 19]
                    
                                                                 Многократная маркировка происходит во O(n log (log n))времени.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                 Code Challenge: наивный поиск по шаблону


Наивный поиск по шаблону — это простой способ систематического поиска в тексте заданного шаблона. Этот алгоритм перебирает каждый символ в тексте, 
а затем подсчитывает следующее количество совпадающих символов, чтобы найти шаблон. Он предпочтителен из-за его простоты и легкости реализации, 
что позволяет легко модифицировать его для других целей.

def pattern_search(text, pattern, replacement, case_sensitive=True):
  fixed_text = ""
  num_skips = 0

  for index in range(len(text)):

    if num_skips > 0:
      num_skips -= 1
      continue

    match_count = 0

    for char in range(len(pattern)): 
      if case_sensitive and pattern[char] == text[index + char]:
        match_count += 1
      elif not case_sensitive and pattern[char].lower() == text[index + char].lower(): 
        match_count += 1
      else:
        break

    if match_count == len(pattern):
      print(pattern, "found at index", index)
      fixed_text += replacement
      num_skips = len(pattern)-1
    else:
      fixed_text += text[index]

  return fixed_text

friends_intro = "Pylhon is a wonderful Language that zzz is beloved for its ease zzz of use and simple syntacs. While zzz at some times the performance can be less 
than iDil, by properly zzz utilizing built-in libraries and other languuUuage features, pylhon's performance zzz can approach that of C."
pattern_search(friends_intro, "Language", "language")
pattern_search(friends_intro, "pylhon", "Python", False)
pattern_search(friends_intro, "idil", "ideal", False)
pattern_search(friends_intro, "zzz ", "")
pattern_search(friends_intro, "syntacs", "syntax")
pattern_search(friends_intro, "languuUuage", "language")
---------------------------------------------------------------------------------------------------------------------------------------------------------------
                                            система управления реляционными базами данных.
Реляционная база данных — это тип базы данных
Таблицы могут содержать сотни, тысячи, а иногда и миллионы строк данных. Эти строки часто называют записями .
Система управления реляционными базами данных (RDBMS) — это программа, которая позволяет создавать, обновлять и администрировать реляционную базу данных.
SQL ( язык структурированных запросов ) — это язык программирования , используемый для связи с данными , хранящимися в системе управления реляционными базами данных

MySQL —--- самая популярная база данных SQL с открытым исходным кодом.
           Основные преимущества MySQL заключаются в том, что она проста в использовании, недорога, надежна (существует с 1995 г.) и имеет большое сообщество разработчиков
           Некоторые из недостатков заключаются в том, что известно, что он страдает от низкой производительности при масштабировании

PostgreSQL — это база данных SQL с открытым исходным кодом, которая не контролируется какой-либо корпорацией.
             PostgreSQL обладает многими из тех же преимуществ, что и MySQL. Он прост в использовании, недорог, надежен и имеет большое сообщество разработчиков
             Основным недостатком PostgreSQL является то, что он может быть медленнее по производительности

БД Oracle---Корпорация Oracle владеет базой данных Oracle, и исходный код не является открытым.
            Oracle DB предназначена для крупных приложений, особенно в банковской сфере
            Основным недостатком использования Oracle является то, что он не бесплатный, 

SQL-сервер -----Microsoft владеет SQL Server. Как и в Oracle DB, исходный код закрыт.Крупные корпоративные приложения в основном используют SQL Server.
                но она может стать очень дорогой по мере масштабирования приложения.

SQLite —     популярная база данных SQL с открытым исходным кодом. Он может хранить всю базу данных в одном файле
             Одним из наиболее значительных преимуществ этого является то, что все данные могут храниться локально без 
             необходимости подключения вашей базы данных к серверу.
             SQLite — популярный выбор для баз данных в мобильных телефонах, КПК, MP3-плеерах,


Реляционные базы данных хранят данные в таблицах. Таблицы могут увеличиваться в размерах и содержать множество столбцов и записей.
Системы управления реляционными базами данных (RDBMS) используют SQL (и варианты SQL) для управления данными в этих больших таблицах. 
Выбор СУБД зависит от сложности вашего приложения.

                                                           Введение в NoSQL

NoSQL означает «не только SQL» (также называемый «нереляционный» или «не-SQL») и относится к любой базе данных, 
которая хранит данные в любом формате, отличном от реляционных таблиц.

Популярность технологии баз данных NoSQL росла из-за увеличения размера и сложности наборов данных.

Базы данных NoSQL могут обеспечить гибкость, масштабируемость и преимущества в скорости.

Базы данных NoSQL имеют такие недостатки, как отсутствие целостности данных и отсутствие языковой стандартизации в разных базах данных NoSQL.

Общие типы баз данных NoSQL включают ключ-значение,  документ,  граф  и  столбцы.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                   Введение в SQL

SQL ( язык структурированных запросов ) — это язык программирования, предназначенный для управления данными, хранящимися в реляционных базах данных .

      SELECT * FROM celebs;        будете запускать все свои SQL-команды 

Реляционная база данных — это база данных , в которой информация организована в одну или несколько таблиц
Таблица — это набор данных, организованных в строки и столбцы . Таблицы иногда называют отношениями . Вот таблица celebs.
Столбец — это набор значений данных определенного типа. Здесь , id, nameи age– столбцы.
Строка — это одна запись в таблице. В первой строке таблицы celebs есть:

Все данные, хранящиеся в реляционной базе данных, относятся к определенному типу данных . Некоторые из наиболее распространенных типов данных:

INTEGER, положительное или отрицательное целое число
TEXT, текстовая строка
DATE, дата в формате ГГГГ-ММ-ДД
REAL, десятичное значение

---------------------------------
1   |	Justin Bieber	 |   22
2   |	Beyonce Knowles	 |   33
3   |	Jeremy Lin	 |   26
4   |	Taylor Swift	 |   26
---------------------------------  
     Database Schema
         celebs
---------------------------------
name	      type

id	     INTEGER   (ЦЕЛОЕ ЧИСЛО)
name	      TEXT      (ТЕКСТ)
age	     INTEGER   (ЦЕЛОЕ ЧИСЛО)
Rows:          4
---------------------------------
          Заявления
Приведенный ниже код является оператором SQL. Оператор — это текст, 
который база данных распознает как допустимую команду. Операторы всегда заканчиваются точкой с запятой ;

CREATE TABLE table_name (
   column_1 data_type, 
   column_2 data_type, 
   column_3 data_type
);
CREATE TABLE   является оговоркой . Предложения выполняют определенные задачи в SQL. 

table_name    относится к имени таблицы, к которой применяется команда.

(column_1 data_type, column_2 data_type, column_3 data_type)является параметром . Параметр — это список столбцов, типов данных или значений,

Создавать
CREATE  операторы позволяют нам создать новую таблицу в базе данных.

CREATE TABLE celebs (            CREATE TABLE— это предложение, которое сообщает SQL, что вы хотите создать новую таблицу.
                                               celebs имя таблицы
   id INTEGER,                   id является первым столбцом в таблице. Он хранит значения типа данных INTEGER
   name TEXT,                    name является вторым столбцом в таблице. Он хранит значения типа данных TEXT
   age INTEGER                   age является третьим столбцом в таблице. Он хранит значения типа данных  INTEGER
);

Вставлять
Оператор INSERT вставляет новую строку в таблицу.

INSERT INTO celebs (id, name, age)        INSERT INTO это предложение, которое добавляет указанную строку или строки celebs таблица, в которую добавляется строка.
VALUES (1, 'Justin Bieber', 22);          (id, name, age)— параметр, определяющий столбцы, в которые будут вставлены данные.
                                          VALUES является предложением, указывающим на вставляемые данные.
                                          (1, 'Justin Bieber', 22)является параметром, идентифицирующим вставляемые значения.

SELECT Операторы используются для извлечения данных из базы данных.SELECT возвращаются все данные в name столбце таблицы celebs.

SELECT name FROM celebs;          . SELECT— это предложение, указывающее, что оператор является запросом
                                  . name указывает столбец для запроса данных.
                                  . FROM celebs указывает имя таблицы для запроса данных   
SELECT * FROM celebs;             *— это специальный подстановочный знак, который мы использовали.выбирать каждый столбец в таблице 
                                   без необходимости называть каждый из них по отдельности.

ALTER TABLE добавляет новый столбец в таблицу. 

ALTER TABLE celebs                 Оператор  добавляет новый столбец twitter_handle в celebsтаблицу.

ALTER TABLE celebs 
ADD COLUMN twitter_handle TEXT;    1. ALTER TABLE— это пункт, который позволяет вам вносить указанные изменения.
                                   2. celebs— это имя изменяемой таблицы.
                                   3. ADD COLUMN— это предложение, позволяющее добавить в таблицу новый столбец:
                                      .twitter_handle имя добавляемого нового столбца
                                      .TEXT тип данных для нового столбца
                                   4. NULL— это специальное значение в SQL, обозначающее отсутствующие или неизвестные данные

UPDATE  редактирует строку в таблице. Вы можете использовать UPDATEоператор, когда хотите изменить существующие записи.

UPDATE celebs                            1. UPDATE— это предложение, которое редактирует строку в таблице.
SET twitter_handle = '@taylorswift13'    2. celebs имя таблицы.
WHERE id = 4;                            3. SET— это предложение, указывающее столбец для редактирования.
                                            .twitter_handleэто имя столбца, который будет обновлен
                                            .@taylorswift13это новое значение, которое будет вставлено в twitter_handle столбец.
                                         4. WHERE— это предложение, указывающее, какие строки необходимо обновить с помощью нового значения столбца

DELETE FROM   удаляет одну или несколько строк из таблицы. Оператор ниже удаляет все записи в celebs таблице без twitter_handle:

DELETE FROM celebs                       1. DELETE FROM это предложение, которое позволяет вам удалять строки из таблицы.
WHERE twitter_handle IS NULL;            2. celebs— это имя таблицы, из которой мы хотим удалить строки.
                                         3. WHERE это предложение, которое позволяет вам выбрать, какие строки вы хотите удалить.
                                         4. IS NULL это условие в SQL, которое возвращает true, если значение равно, NULL и false в противном случае.

Constraints   Ограничения , добавляющие информацию о том, как можно использовать столбец, вызываются после указания типа данных для столбца.

CREATE TABLE celebs (
   id INTEGER PRIMARY KEY,                     1. PRIMARY KEY Столбцы могут использоваться для уникальной идентификации строки.
   name TEXT UNIQUE,                           2. UNIQUE столбцы имеют разные значения для каждой строки.
   date_of_birth TEXT NOT NULL,                3. NOT NULLстолбцы должны иметь значение. Попытки вставить строку без значения для NOT NULL
                                                  столбца приведут к нарушению ограничения
   date_of_death TEXT DEFAULT 'Not Applicable' 4. DEFAULT столбцы принимают дополнительный аргумент, который будет предполагаемым значением для вставленной строки.
);

SQL — это язык программирования, предназначенный для манипулирования и управления данными, хранящимися в реляционных базах данных.
      Язык структурированных запросов

Реляционная база данных — это база данных, в которой информация организована в одну или несколько таблиц.
Таблица — это набор данных, организованных в строки и столбцы .
Оператор — это строка символов, которую база данных распознает как допустимую команду .

CREATE TABLEсоздает новую таблицу.
INSERT INTOдобавляет новую строку в таблицу.
SELECTзапрашивает данные из таблицы.
ALTER TABLEизменяет существующую таблицу.
UPDATEредактирует строку в таблице.
DELETE FROMудаляет строки из таблицы.
Ограничения добавляют информацию о том, как можно использовать столбец.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                  QUERIES - ЗАПРОСЫ
Одной из основных целей языка SQL является извлечение информации, хранящейся в базе данных. Это обычно называют запросом.
Запросы позволяют нам взаимодействовать с базой данных, задавая вопросы и возвращая набор результатов с данными, относящимися к вопросу

Подведем итог:

SELECT           это предложение, которое мы используем каждый раз, когда хотим запросить информацию из базы данных.

AS               переименовывает столбец или таблицу.

DISTINCT         возвращать уникальные значения.

WHERE—           популярная команда, позволяющая фильтровать результаты запроса на основе заданных вами условий.

LIKE и BETWEEN   являются специальными операторами.

AND и OR         сочетает в себе несколько условий.

ORDER BY         сортирует результат.

LIMIT            указывает максимальное количество строк, которые вернет запрос.

CASE             создает разные выходы.

SELECT name, 
 CASE
  WHEN genre = 'romance' THEN 'Chill'
  WHEN genre = 'comedy'  THEN 'Chill'
  ELSE 'Intense'
 END AS 'Mood'
FROM movies
ORDER BY year DESC

LIMIT 14;

-------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                      АГРЕГАТНЫЕ ФУНКЦИИ

COUNT():                    подсчитать количество строк

SUM():                      сумма значений в столбце

MAX()/ MIN():               наибольшее/наименьшее значение

AVG():                      среднее значение в столбце

ROUND():                    округлить значения в столбце 

Агрегатные функции объединяют несколько строк вместе, чтобы сформировать одно значение более значимой информации.

GROUP BY             это предложение, используемое с агрегатными функциями для объединения данных из одного или нескольких столбцов.

HAVING               ограничить результаты запроса на основе совокупного свойства.

SELECT COUNT(*)
FROM fake_apps;
SELECT SUM(downloads)
FROM fake_apps;
SELECT MAX(name)
FROM fake_apps;
SELECT ROUND(price, 3)
FROM fake_apps;
SELECT AVG(downloads)
FROM fake_apps
GROUP BY name
ORDER BY name
LIMIT 15;
--------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                       НЕСКОЛЬКО ТАБЛИЦ
    Kак запрашивать информацию из нескольких таблиц с помощью SQL.

JOIN-            объединит строки из разных таблиц, если условие соединения истинно.

LEFT JOIN        вернет каждую строку в левой таблице, и если условие соединения не выполняется, NULLзначения используются для заполнения столбцов из правой таблицы.

Первичный ключ — это столбец, который служит уникальным идентификатором для строк в таблице.

Внешний ключ —   это столбец, содержащий первичный ключ к другой таблице.

CROSS JOIN       позволяет объединить все строки одной таблицы со всеми строками другой таблицы.

UNION            размещает один набор данных поверх другого.

WITH            позволяет нам определить одну или несколько временных таблиц, которые можно использовать в конечном запросе.

WITH previous_query AS (
   SELECT customer_id,
      COUNT(subscription_id) AS 'subscriptions'
   FROM orders
   GROUP BY customer_id
)
SELECT customers.customer_name, 
   previous_query.subscriptions
FROM previous_query
JOIN customers
  ON previous_query.customer_id = customers.customer_id;

----------------------------------------------------------------------------------------------------------------------------------------------------
                                                                          СХЕМА БАЗЫ ДАННЫХ
PostgreSQL — это популярная система управления базами данных, которая хранит информацию на выделенном сервере базы данных,а не в локальной файловой системе. 
При проектировании схемы базы данных рассмотрите следующие шаги:

Определите назначение вашей базы данных
Найти информацию, которая составляет базу данных
Организуйте информацию в таблицы
Структурируйте свои таблицы в столбцы информации
Избегайте избыточных данных, которые приводят к неточностям и потерям в пространстве
Определите отношения между вашими таблицами и реализуйте их

Вы можете создавать схемы базы данных вручную или с помощью программного обеспечения.Вот несколько примеров бесплатных онлайн-инструментов для создания баз данных:

DbDiagram.io — бесплатный простой инструмент для рисования ER-диаграмм простым написанием кода, предназначенный для разработчиков и аналитиков данных.

SQLDBM — средство моделирования баз данных SQL

DB Designer --  онлайн-инструмент для проектирования и моделирования схемы базы данных

Схема вашей базы данных должна содержать следующее:

имена таблиц
имена столбцов в таблице
типы столбцов на таблицу
ограничения на таблицу, если таковые имеются
отношения между таблицами, если таковые имеются

SELECT * from profile;    cedvelde evvelce bundan istifade olunur profilin yerinde ad  olur.
                          burda ice cedvelde ne olacag onlar yazilir  mes, title kitabin adi varchar 100 vregden ibaret. onda olacag title varchar(100)
  CREATE TABLE book (
  title varchar(100),
  isbn varchar(50),
  pages integer
   );
  INSERT INTO book VALUES (
  'Postgres for Beginners',        nese elave etmek istesek bele olacag
  '0-5980-6249-1',
  25
   );
  
   SELECT * from table_name;                             Чтобы запросить таблицу для возврата всех столбцов, введите:

   SELECT * FROM book WHERE isbn = '0-5980-6249-1';     eger bir seyden cox olarsa birini gaytarmag ucun bundan ist. etmek olar

   SELECT * from chapter;                      cedvelleri birlesdirmek ucun bundan istifade edilecek.yeni chapter ile author ondanda book birlesecek
   SELECT * FROM author;
   SELECT * FROM book;
-------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                        КЛЮЧИ БАЗЫ ДАННЫХ
Ключ базы данных — это столбец или группа столбцов в таблице, которые однозначно идентифицируют строку в таблице.
Ключи позволяют разработчику базы данных накладывать ограничения на данные в таблице.
Существует много типов ключей: Super, Candidate, Primary, Foreign, Composite и Secondary.

Primary Key(Основной ключ)--Первичный ключ — это обозначение, которое применяется к столбцу или нескольким столбцам таблицы и
                            однозначно идентифицирует каждую строку в таблице. гарантирует, что данные этого столбца всегда уникальны и не равны нулю.
                            Например, следующий код определяет id столбец как первичный ключ для recipe таблицы.
  CREATE TABLE recipe (                yeni secdiyin sozden sonra PRIMARY KEY yazirsan.
    id integer PRIMARY KEY,
  name varchar(20),
  ...
    );

SELECT                                             bununla cedvelde acarin harda olmasini tapa bilerik dirnag arasinda cedvelin adini yazacagig.
  constraint_name, table_name, column_name
FROM                                              
 information_schema.key_column_usage               
WHERE
  table_name = '___';                                    
---------------------------------------------
 constraint_name | table_name | column_name |
-----------------+------------+-------------|       pkey относится к ограничению первичного ключа, а fkey относится к ограничению внешнего ключа.bunlar cedvelde
                 |            |             |                yazilir.
 recipe_pkey     | recipe     | id          |   
(1 row)                                     |
---------------------------------------------
                                                    Чтобы назначить несколько столбцов составным первичным ключом, используйте следующий синтаксис:

CREATE TABLE popular_books (
  book_title varchar(100),                          burda axirda primary key de 2 si yazilir sonra yene SELECT yazilir yuxaridaki kimi 
  author_name varchar(50),
  number_sold integer,
  number_previewed integer,
  PRIMARY KEY (book_title, author_name)
);
---------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                      Внешний ключ, часть 1
 Внешний ключ — это ключ, который ссылается на столбец в другой таблице.

CREATE TABLE email (                                 Чтобы указать внешний ключ для одного столбца в PostgreSQL, мы используем REFERENCES ключевое слово:
  email varchar(20) PRIMARY KEY,                     REFERENCE ile gosterilir burdada axirda select yazilir
  person_id integer REFERENCES person(id),            связали две таблицы вместе с помощью внешнего ключа, вы удостоверились, 
  storage integer,                                    что можете правильно соединить таблицы вместе в запросе.
  price money
);
                                                    Например, предположим, что мы хотим снова соединить таблицы personи emailиз следующей схемы:
                                                    Мы могли бы использовать следующий запрос для возврата таблицы имен и связанных адресов электронной почты:
SELECT person.name AS name, email.email AS email
FROM person, email
WHERE person.id = email.person_id;
                                                         

SELECT column_one AS alias_one, column_two AS alias_two
FROM table_one, table_two                                         Используйте первичный ключ bookи внешний ключ для chapter написания этого запроса. 
WHERE table_one.primary_key = table_two.foreign_key


SELECT * FROM book;
SELECT * FROM chapter;
SELECT book.title as book, chapter.title as chapters      Мы также можем использовать JOIN оператор следующим образом:
FROM book
JOIN chapter
ON book.isbn = chapter.book_isbn;
---------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                   ОТНОШЕНИЯ БАЗЫ ДАННЫХ
Существует три типа: один-к-одному, один-ко-многим и многие-ко-многим.

Отношения один к одному: В отношении «один к одному» строка таблицы A связана ровно с одной строкой таблицы B и наоборот.

Чтобы обеспечить строгую взаимосвязь в PostgreSQL, нам нужно еще одно ключевое слово, UNIQUE.

CREATE TABLE driver (                              Burda drver license ile birlesdirmek isteyirik, primary key olan acar sozu gotururuk yazirig licensede  
    license_id char(20) PRIMARY KEY,               sonra daliyaca REFERENCES sozu sonra hansi cedvelnen birlesdirmek isteyirikse onun adini 
    name varchar(20),                              moterizede acarin adini meselen driver(license_id) yazirig . Eger bu sozden cox olarsa tekrar alem garismasin 
    address varchar(100),                          deye UNIQUE sozunu yazacagig.Hokmen deyil PRIMARY KEY olan sozu yazasan basgasinida sece bilersen.
    date_of_birth date
);      
 
CREATE TABLE license (
    id integer PRIMARY KEY,
    state_issued varchar(20),
    date_issued date,
    date_expired  date,
    license_id char(20) REFERENCES driver(license_id) UNIQUE
); 

----------------------------------------------------------------
Связь «один ко многим»:В отличие от отношения «один к одному», отношение «один ко многим» не может быть представлено в одной таблице.
                        Поскольку для первичного ключа потребуется несколько строк, это приведет к избыточным данным,
                        которые нарушат ограничение, наложенное на первичный ключ.
                        родительская таблица будет содержать первичный ключ, а дочерняя таблица будет содержать как первичный,
                        так и внешний ключи. Внешний ключ связывает дочернюю таблицу с родительской таблицей.
CREATE TABLE page (
  id integer PRIMARY KEY,                              demeli, bunu birlesdirmekden otru charter_id (bu evvelceden yazilan cedveldi) yazirig bura sonra charter
  chapter_id integer REFERENCES chapter(id),            sozunu o biri cedvelden silirik (ALTER TABLE vasitesile) sonra Select yoxlayirig ne var ne yox  Bundan
  content text,                                         sonra INSERT le cedvellere elave ler edirik (3 dene cedveldi) ve axirda INNER JOIN vasitesile 
  header varchar(20),                                    cedvelleri birlesdiririk.
  footer varchar(20)
);

ALTER TABLE chapter
DROP COLUMN content;

SELECT
  constraint_name, table_name, column_name
FROM
  information_schema.key_column_usage
WHERE
  table_name = 'page';

INSERT INTO book VALUES (
  'Learn PostgreSQL',
  '0-9673-4537-5',
  100,
  2.99,
  'Dive into Postgres for Beginners',
  'Codecademy Publishing'
);
------------------------------------------------------------------
Отношения «многие ко многим», часть 1
                                            Чтобы реализовать отношение «многие ко многим» в реляционной базе данных, мы создадим третью таблицу перекрестных ссылок
                                            также известную как таблица соединения. 
                                            будет иметь эти два ограничения:  внешние ключи, ссылающиеся на первичные ключи двух таблиц-члено
                                                                   составной первичный ключ, состоящий из двух внешних ключей.
                              
CREATE TABLE books_authors (                           Создайте таблицу перекрестных ссылок, books_authorsкоторая имеет следующие столбцы:
  book_isbn varchar(50) REFERENCES book(isbn),            book_isbnof varchar(50), который служит внешним ключом для таблицы bookи isbn столбца
  author_email varchar(20) REFERENCES author(email),
  PRIMARY KEY (book_isbn, author_email)                   author_emailof varchar(20), который служит внешним ключом для author таблицы и email столбца
);
SELECT                                                     Создайте составной первичный ключ для books_authors from book_isbn и author_email.
  constraint_name, table_name, column_name                Axirda yene SELECT yoxlayirig
FROM
  information_schema.key_column_usage
WHERE
  table_name = 'books_authors';
------------------------------------------------------------------
   Отношения «многие ко многим», часть 2:   Теперь, когда вы связали две таблицы отношением «многие ко многим» через таблицу перекрестных ссылок, 
                                           вы сможете заполнить таблицу перекрестных ссылок и сделать интересные запросы.

                                          В этом упражнении вы продемонстрируете отношение «многие ко многим» между таблицей перекрестных ссылок bookи 
                                            через нее .authorbooks_authors
SELECT * FROM book;
SELECT * FROM author;

INSERT INTO books_authors VALUES (
  '123457890',                                        Первичные ключи для books:'123457890'для'Learn PostgreSQL Volume 1'
                                                                                '987654321'для'Learn PostgreSQL Volume 2'
  'jkey@db.com'
);

INSERT INTO books_authors VALUES (
  '123457890',                                      Первичные ключи для authors:'jkey@db.com'для'James Key'
                                                                                'cindex@db.com'для'Clara Index'
  'cindex@db.com'
);

INSERT INTO books_authors VALUES (
  '987654321',
  'cindex@db.com'
);

SELECT
    book.title AS book_title,            <-------  Чтобы отобразить выбранные столбцы ( column_oneи column_two) из разных таблиц ( table_oneи table_two) как псевдонимы
    author.name AS author_name,                     ( alias_oneи alias_two) и соединить их с помощью таблицы перекрестных ссылок (joined_table),
    book.description AS book_description                  используйте следующий синтаксис:
FROM
    book, author, books_authors
WHERE
    book.isbn = books_authors.book_isbn
AND
    author.email = books_authors.author_email;

SELECT
    author.name AS author_name,
    author.email AS author_email,                    В качестве альтернативы вы можете запросить INNER JOIN из трех таблиц.
    book.title AS book_title
FROM
    book                                                                  
JOIN
    books_authors
ON
    book.isbn = books_authors.book_isbn
JOIN
    author
ON
    author.email = books_authors.author_email;
--------------------------------------------------------------------------------------------------------------------------------------------
                                                                    ТРИГГЕРЫ БАЗЫ ДАННЫХ
 триггер базы данных — это процедурный код, который автоматически выполняется в ответ на определенные события в конкретной таблице или представлении в базе данных.
                       Триггер в основном используется для поддержания целостности информации в базе данных».
                       когда кто-то вносит определенное изменение в таблицу или представление, триггер помещается в эту таблицу или представление.
                       Этот триггер вызовет функцию, когда будут выполнены условия для триггера.

SELECT *                В этом упражнении вы собираетесь активировать этот триггер и посмотреть, как он влияет на ваши данные.
FROM customers;         Сначала проверьте начальное состояние таблицы, customersпрежде чем вносить какие-либо изменения. А SELECT *на этом столе будет хорошо.
                        Напишите UPDATE заявление в customers таблице в SET столбце years_old для 42 любого клиента last_name с Hall.
UPDATE customers        Напишите свое SELECTзаявление еще раз после вашего UPDATEзаявления. Триггер сделал это дополнительное изменение.
SET years_old = 42
WHERE last_name = 'Hall';

SELECT *
FROM customers;
-----------------------------------------------------     Как активируются триггеры?

CREATE TRIGGER <trigger_name>                  Если вы работаете в другой системе, возможно, вам придется переключиться на EXECUTE FUNCTION.
BEFORE UPDATE ON <table_name>
FOR EACH ROW
EXECUTE PROCEDURE<function>;                  предположим, что у вас есть собственная функция триггера, и check_account_update()она может быть написана так:
                                              Вы можете установить эту функцию в качестве цели вашего триггера следующим образом:

CREATE TRIGGER check_update 
    BEFORE UPDATE ON accounts                 Вы не ограничены установкой триггера только для UPDATE, его можно установить для UPDATE, и .INSERT, DELETE,TRUNCATE.
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();

-------------------------------------------------------     Когда срабатывает триггер?

 Есть два распространенных варианта: BEFOREи AFTER.
 BEFORE ----- В частности, позволяя вам изменить строку, которая изменяется при использовании INSERT или UPDATE, как мы делали в предыдущем уроке.
 AFTER ------ происходит, когда запрос завершает свою работу. Это позволяет вашему триггеру активироваться после того, как запрос, которым он был активирован.

SELECT * FROM customers ORDER BY customer_id;

CREATE TRIGGER after_trigger
  AFTER UPDATE ON customers                             Применим пример на практике и создадим AFTER триггер.
  FOR EACH ROW                              
  EXECUTE PROCEDURE log_customers_change();            log_customers_change()это функция, которую мы написали за кулисами,
                                                       которая будет регистрировать время внесения изменений в таблицу customers.
UPDATE customers
SET years_old = years_old + 10                        Добавьте еще один SELECT *, customers_log чтобы вы могли видеть журнал, который был создан при вашем изменении.
WHERE customer_id = 1;

SELECT * FROM customers ORDER BY customer_id;

SELECT * FROM customers_log;
----------------------------------------------------------   Какие записи изменяются триггером?

 рассмотрим эту FOR EACH ROW часть нашего триггера. При использовании FOR EACH ROW триггер срабатывает и вызывает функцию для каждой строки, 
 на которую влияет связанный запрос.
 Другой вариант - установить его в FOR EACH STATEMENT. FOR EACH STATEMENT вызывает функцию в триггере один раз для каждого запроса, а не для каждой записи.

SELECT * FROM customers;
CREATE TRIGGER each_statement_trigger
AFTER UPDATE ON customers
FOR EACH ROW                                              bunu deyismekle funksiyada deyisiklik ede bilerik
EXECUTE PROCEDURE statement_function();
UPDATE customers
SET years_old = years_old + 1;
SELECT * FROM customers;
---------------------------------------------------------  Могу ли я сфокусировать свои триггеры?

 вы можете использовать WHEN предложение для фильтрации, когда триггер вызывает связанную с ним функцию.
  WHEN предложением вы можете использовать NEW и OLD для получения записей из таблицы до и после запроса.
   Логически, INSERT не может ссылаться OLD(ничего не существовало до вставки) и DELETE не может ссылаться NEW(ничего не существует после удаления).

CREATE TRIGGER update_trigger_high
  BEFORE UPDATE ON clients
  FOR EACH ROW
  WHEN (NEW.total_spent >= 1000)
  EXECUTE PROCEDURE set_high_spender();

CREATE TRIGGER update_trigger_low
  BEFORE UPDATE ON clients
  FOR EACH ROW
  WHEN (NEW.total_spent < 1000)
  EXECUTE PROCEDURE set_low_spender();                Например, INSERT триггеры могут выглядеть 

SELECT * FROM clients ORDER BY client_id;

UPDATE clients
SET total_spent = 5000                             чтобы протестировать наши триггеры, напишите два оператора обновления. 
WHERE last_name = 'Campbell';                       Во-первых, установите total_spent = 5000 where last_name = 'Campbell'

UPDATE clients
SET total_spent = 100                                Для второго установите total_spent = 100 где last_name = 'Lewis'.
WHERE last_name = 'Lewis';                            Запускайте SELECT *снова clientsи ORDER BY client_idснова после своего UPDATEзаявления 
                                                     Триггер изменил запись сверх того, что было указано в UPDATEзаявлении
SELECT * FROM clients ORDER BY client_id;                    
------------------------------------------------------    Что следует учитывать

в PostgreSQL в одной таблице может существовать несколько триггеров одного типа. Если оператор вызывает срабатывание нескольких триггеров,
 они срабатывают в алфавитном порядке. 
 Еще один момент, о котором следует помнить, заключается в том, что в PostgreSQL, поскольку SELECTоператоры не изменяют строки,
  для оператора нельзя установить триггер SELECT.                                       

CREATE TRIGGER update_alpha
  BEFORE UPDATE ON orders
  FOR EACH ROW
  EXECUTE PROCEDURE update_first();

CREATE TRIGGER update_bravo
  BEFORE UPDATE ON orders
  FOR EACH ROW
  EXECUTE PROCEDURE update_second();

SELECT *
FROM orders
ORDER BY order_id;
                                                         UPDATE запись для заказа 1234 с количеством 5.
UPDATE orders
SET quantity = 5                                       
WHERE order_id = 1234;

SELECT *
FROM orders
ORDER BY order_id;
-------------------------------------------------               Удаление триггеров

 в вашей базе данных, триггеры необходимо поддерживать, а иногда это означает удаление устаревших триггеров. Вы можете использовать DROP TRIGGER для этого.

DROP TRIGGER <trigger_name> ON <table_name>;    Например:   DROP TRIGGER insert_trigger ON customers;

В дополнение к отбрасыванию триггеров может быть полезно знать, какие триггеры существуют. Чтобы найти это,
 вам просто нужно посмотреть на information_schema.triggersтаблицу.

  SELECT * FROM information_schema.triggers;
                                                   evvelce SELECT yazarag yoxlayirig hansi tiggerler var mes orders cedvelde olan  im_a_bad_trigger legv etmek istesen
  DROP TRIGGER im_a_bad_trigger ON orders;             bele edeceyik.sonra tezden SELECT nen yoxlayacagig  hansi teggerler galib.

  SELECT * FROM information_schema.triggers;
-----------------------------------------------------
В этом уроке о триггерах в PostgreSQL мы рассмотрели, как:

Триггеры связаны с определенной таблицей, представлением или внешней таблицей.
Триггеры выполняют указанную функцию, когда над таблицей выполняются определенные операции ( INSERT, UPDATE, DELETE, TRUNCATE).
Триггеры могут запускаться до, после или вместо попытки операции изменить строку.
Набор триггеров FOR EACH ROWвызывается один раз для каждой измененной строки.
FOR EACH STATEMENTвыполняется один раз для всей операции (0 измененных строк все равно вызовет это).
Триггеры могут указывать логическое WHENусловие, чтобы увидеть, когда они должны быть запущены.
В одной таблице может существовать несколько триггеров одного типа. Если да, то они запускаются в алфавитном порядке.
SELECTоператоры не изменяют строки, поэтому для оператора нельзя установить триггер SELECT.
Одна команда SQL может запускать более одного типа триггера.
Используйте DROP TRIGGERкоманду для удаления триггера.
Вы можете запросить information_schema.triggersтаблицу, чтобы получить список триггеров в системе.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                           Представление схемы с помощью диаграмм отношений сущностей
 При работе с базой данных всплывают схемы, помогающие описать базу данных.
 Схемы базы данных часто изображаются в виде диаграмм — больших изображений, показывающих каждую таблицу и то, как они связаны.
 
Диаграмма отношений сущностей , или ERD , — это метод построения диаграммы базы данных с добавлением в нее немного большего описания,
                                позволяющего разработчику лучше понять базу данных и отношения между таблицами.

  Сущности . Сущности обычно представляются в виде прямоугольников и обозначают имя таблицы.

  Атрибуты . Атрибуты можно найти в одном из двух мест: либо внутри прямоугольников объекта в виде строк, либо за пределами объекта,
              представленного овалом, соединенным с объектом.

  Действия . Действия рассматриваются как ромбы в ERD и описывают отношения между различными объектами. Например, если у нас есть две сущности.

  Соединительные линии . Эти линии, как и в базовой схеме, используются для отображения связи между каждым объектом, действием и атрибутом.

  Как создать схему   При построении схемы доступно несколько инструментов, которые помогут вам создать аккуратную схему.
                      Схема, разработанная в Интернете, — это схема, разработанная в Интернете.dbdiagram.io , dbdesigner.net , lucidchart.com 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                    Трехуровневая архитектура.

При разработке приложения, скорее всего, будет обсуждаться количество уровней, которые будет использовать приложение.
В большинстве случаев будет выбрана трехуровневая архитектура, поскольку она подходит для большого количества вариантов использования с приложением.

В этой структуре тремя уровнями являются уровень представления, уровень приложений и уровень данных. 

Уровень представления  Этот уровень знаком большинству людей, поскольку он представляет такие элементы, как пользовательский интерфейс или графический интерфейс.
                       . Он представляет, как пользователь будет взаимодействовать с приложением.Этот уровень состоит в основном из языков разметки,
                          включая HTML, JavaScript и CSS.
Уровень данных        Это уровень, на котором хранятся все данные. Данные на этом уровне не обрабатываются и предназначены исключительно для хранения.
                       Обычно это просто база данных для хранения данных. Уровень данных может взаимодействовать только с уровнем приложений и
                        не может связываться напрямую с уровнем представления. 
                      Уровень данных приложений обычно представляет собой базу данных, а это означает, что такие службы, как SQL, MongoDB и PostgreSQL.
Уровень приложений    Этот уровень будет обрабатывать данные, собранные на уровне представления, и изменять данные на уровне данных.
                       Он действует как мост, соединяющий два других яруса.
                      Большая часть работы, выполняемой внутри уровня приложений, будет выполняться на таких языках программирования, как Java, Python, Perl 
                      и других популярных языках программирования.. Это потому, что они лучше всего умеют манипулировать данными в различных формах. 

Самым большим из них является дополнительная помощь в проектировании и разработке, а также простота масштабирования программ по мере роста использования с 
течением времени.

Другие многоуровневые архитектуры  В мире разработки существует двухуровневая архитектура, которая содержит только уровень представления и уровень данных.
                                   Приложения также могут содержать более трех уровней. что нет настоящего ограничения на количество уровней,
 Различные уровни также помогают улучшить масштабируемость, когда приложение растет, и им легче управлять, чем приложением более высокого уровня.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                        POSTGRES PRO
Ограничения — это правила, определенные как часть модели данных для управления допустимыми значениями в определенных столбцах и таблицах.
 ограничений может улучшить нашу модель данных:

Типы данных
NOT NULLограничения
UNIQUEограничения
PRIMARY KEYограничения
CHECKограничения
FOREIGN KEYОграничения

В CREATE TABLE операторе мы указываем тип данных для каждого столбца таблицы (например, int, text, timestampи т. д.). При этом мы сообщаем PostgreSQL, 
какие типы значений можно вставлять в каждый столбец таблицы
-------------------------------------------
не могут быть NULLдо создания нашей таблицы, мы можем добавить NOT NULLограничение после типа данных в операторе таблицы CREATE TABLE.

CREATE TABLE speakers (
    id integer NOT NULL,
    email varchar NOT NULL,
    name varchar NOT NULL,
    organization varchar,
    title varchar,
    years_in_role integer 
);
INSERT INTO speakers (id, email, name, organization, title, years_in_role)
VALUES (1, 'awilson@ABCcorp.com', 'A. Wilson', 'ABC Corp.', 'CTO', 6);
-------------------------------------------
В PostgreSQL мы можем использовать ALTER TABLE операторы для добавления или удаления ограничений из существующих таблиц. 
ALTER TABLE talks
ALTER COLUMN session_timeslot SET NOT NULL;

Если позже мы решим, что нам больше не нужно это ограничение, мы можем удалить ограничение NOT NULLиз существующей таблицы с помощью следующего оператора:

ALTER TABLE talks
ALTER COLUMN session_timeslot DROP NOT NULL
----------------------------------------------
Ограничение CHECK можно записать в CREATE TABLE оператор или добавить в существующую таблицу с помощью ALTER TABLE.
Чтобы использовать проверочное ограничение, мы перечисляем CHECK (...)следующий тип данных в CREATE TABLEоператоре и пишем условие, 
которое мы хотели бы проверить, внутри круглых скобок.
Давайте добавим CHECKоператор, чтобы наша talksтаблица имела положительное значение estimated_length для каждой строки.

ALTER TABLE talks 
ADD CHECK (estimated_length > 0);
------------------------------------------------
в рамках нашего ограничения проверки мы можем:

Сравнивайте столбцы в таблице
Используйте логические операторы, такие как AND и OR
Используйте другие операторы SQL, с которыми вы, возможно, знакомы ( IN, LIKE)
Мы могли бы применить такую ​​проверку со следующим:

ALTER TABLE talks 
ADD CHECK (estimated_length > 0 AND estimated_length < 120);  
Мы также можем применять ограничения, которые применяются к нескольким столбцам.
ALTER TABLE talks
ADD CHECK (estimated_length < 120 AND date_part('year', session_timeslot) = 2020);

функция date_partв PostgreSQL просто возвращает часть даты в виде целого числа (например, date_part('year' ,'2020-08-01 00:00:00'::date)= 2020).
-----------------------------------------------------
Использование уникальных ограничений
 Мы можем сделать это в CREATE TABLEоператоре, указав столбцы, которые должны быть совместно уникальными, в круглых
 скобках на отдельной строке после имен столбцов и определений типов данных. 
 В этом случае мы бы добавили UNIQUE (speaker_id, session_timeslot)в отдельной строке оператора CREATE TABLE. В этом случае мы бы добавили UNIQUE
  (speaker_id, session_timeslot)в отдельной строке оператора CREATE TABLE.
 
  ALTER TABLE talks
  ADD UNIQUE (speaker_id, session_timeslot)
-----------------------------------------------------------
Введение в первичные ключи

Первичный ключ — это столбец (или набор столбцов), который однозначно идентифицирует строку в таблице базы данных . Таблица может иметь только один 
первичный ключ, и чтобы быть выбранным в качестве первичного ключа, столбец (или набор столбцов) должен:

  Уникально идентифицировать эту строку в таблице (например, UNIQUEограничение)
  Не содержат нулевых значений (например, NOT NULLограничение)

первичные ключи также улучшают вашу модель данных несколькими другими способами:

Многие соединения будут использовать первичный ключ из одной таблицы для объединения данных с другой таблицей.
Первичные ключи могут повысить производительность запросов
Первичные ключи помогают обеспечить целостность данных в таблице, обеспечивая уникальную идентификацию строк.
Теперь давайте добавим idв качестве нашей таблицы PRIMARY KEY, мы можем сделать это с помощью ALTER TABLE инструкции.

ALTER TABLE attendees
ADD PRIMARY KEY (id); 
Даже с первичным ключом все еще есть веская причина использовать комбинацию ограничений UNIQUEи NOT NULLдля обеспечения целостности данных в других столбцах.
-------------------------------------------------
Введение во внешние ключи

Ссылочную целостность можно обеспечить, добавив FOREIGN KEYв дочернюю таблицу, которая ссылается на первичный ключ родительской таблицы.
Если родительская таблица не содержит данных, которые пользователь пытается вставить, PostgreSQL отклонит вставку или обновление и выдаст ошибку.
 Предположим, что talksтакже есть столбец с именем idпервичного ключа. Теперь мы можем обновить нашу таблицу регистраций с помощью 
внешнего ключа, используя следующую инструкцию.

ALTER TABLE registrations
ADD FOREIGN KEY (talk_id) REFERENCES talks (id);
------------------------------------------------
Внешние ключи — каскадные измененияCASCADE предложения ( ON UPDATE CASCADE, ON DELETE CASCADE) заставляют обновления или удаления автоматически 
                применяться к любым дочерним таблицам .

ALTER TABLE talks                                              Давайте реализуем правило, согласно которому, если спикер удаляется, его выступления также удаляются.
ADD FOREIGN KEY (speaker_id)                                    Давайте заполним приведенное ALTER TABLEниже предложением ON DELETE CASCADE, реализующим это правило.
REFERENCES speakers (id) ON DELETE CASCADE;

DELETE FROM speakers where id = 2;                             Давайте проверим, что это ограничение работает. Напишите DELETE заявление о speakers том,             
                                                               что снимут переговоры в динамике с id = 2запланированным докладчиком.
                                                               Проверьте схему таблицы talksдо и после этого удаления (до этого должно быть 20 строк).
                                                               Мы должны увидеть 18 строк talksпосле этого удаления; у этого докладчика должно быть 
                                                               запланировано 2 доклада.
-----------------------------------------------------
Ограничения —          это правила, которые инженер БД определяет как часть модели данных, чтобы лучше контролировать, какие значения разрешены в 
                         определенных столбцах и таблицах.

В частности, ограничения:

Отклоняйте строки, содержащие значения, которые не следует вставлять в таблицу базы данных, что поможет сохранить целостность и качество данных.

Выдавать ошибку при их нарушении, что также может помочь при отладке приложений, записывающих в базу данных.

Существует довольно много типов ограничений:

Типы данных — это ваша первая линия защиты, эти правила не являются ограничениями, но могут помочь отклонить неверные данные из вашей базы данных.

NOT NULLограничения — Отклонить входящие строки из вашей таблицы, если в строке отсутствует важная информация.

CHECKограничения —       дают вам больше контроля над тем, какие правила вы хотели бы применить к своим таблицам. Эти ограничения позволят вам отклонить строку, 
                         если она не соответствует определенным вами критериям.
  
UNIQUEограничения —     помогают определить уникальные значения в таблице, они также создают индекс, который может повысить производительность запросов и соединений.

PRIMARY KEYограничения — столбец или комбинация столбцов, которые однозначно идентифицируют строку и одновременно являются NOT NULLи UNIQUE. PRIMARY KEYs 
                         уникальны для таблицы и часто используются в соединениях между таблицами.

FOREIGN KEYограничения — позволяют поддерживать ссылочную целостность между двумя таблицами, проверяя, что запись в одной также отображается в другой.
                         Ссылочная целостность зависит от FOREIGN KEYограничений.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                            POSTGRESQL: БЕЗОПАСНОСТЬ БАЗЫ ДАННЫХ

Разрешения суперпользователя.          Вы узнали, что такое суперпользователь, какими привилегиями он обладает и когда использовать роль суперпользователя.

            pg_catalog.pg_roles—  список всех пользователей в базе данных и описание специальных разрешений, которыми обладают эти пользователи.
            
            information_schema.table_privileges— описание разрешений пользователя ( grantee) на таблицу.

             SELECT grantor, grantee, table_schema, table_name, privilege_type
             FROM information_schema.table_privileges 
             WHERE grantee = 'userB';
------------------------------------------
Роли группы и входа —                  вы узнали, как можно использовать роли входа и группы для управления наборами пользователей.
                                       Вы можете создать новую роль входа, используя CREATE ROLE <name> WITH <list of permissions>;
  
       CREATE ROLE sampleusr WITH NOSUPERUSER LOGIN
                                     Так же, как таблицы или схемы, роли можно изменять.
                                     Следующий оператор изменяет роль miriamи дает им возможность создавать новые базы данных с CREATEDB.
       ALTER ROLE miriam WITH CREATEDB
--------------------------------------------
Внутренние таблицы разрешений PostgreSQL. Вы узнали о таблицах, на которые можно ссылаться, чтобы контролировать привилегии пользователей в вашей базе данных.
                                         Обладая этими знаниями, вы сможете безопасно делегировать правильные разрешения другим пользователям в базе данных.
                                         Чтобы использовать схему, роль должна иметь разрешение с именем USAGE.
                                         . Без USAGE роли нельзя получить доступ к таблицам в этой схеме. 
                                          Другие разрешения на уровне схемы включают CREATEи DROP, которые позволяют получателю прав создавать 
                                          или удалять таблицы в этой схеме соответственно.
GRANT USAGE, CREATE ON SCHEMA finance TO analyst;   В этом примере analyst также предоставляется возможность создавать CREATE новые таблицы в схеме.

GRANT SELECT, UPDATE ON finance.revenue TO analyst;  Затем, предоставив определенные разрешения для таблицы.

REVOKE UPDATE ON finance.revenue FROM analyst;   Например, чтобы отозвать указанную выше возможность UPDATE, владелец таблицы может использовать следующий оператор:
-------------------------------------------------
Изменение разрешений по умолчанию   -         С разрешениями по умолчанию суперпользователь может установить разрешения, которые будут автоматически                       
                                              обновляться при создании новых объектов в схеме.
                                              Разрешения по умолчанию применяются только к объектам, созданным после установки значений по умолчанию
ALTER DEFAULT PRIVILEGES IN SCHEMA finance    Разрешения по умолчанию также можно использовать для установки разрешений на уровне базы данных.
GRANT SELECT ON TABLES TO analyst;
-------------------------------------------------
Группы и наследование                 Это полезная функция для обслуживания баз данных со многими пользователями, но только с несколькими «типами» пользователей.
                                      Из соображений безопасности PostgreSQL запрещает наследование некоторых мощных разрешений,
                                       таких как LOGIN, SUPERUSER, CREATEDB и CREATEROLE.
CREATE ROLE marketing WITH NOLOGIN ROLE alice, bob;     Использование опции CREATE ROLEи WITH ROLE— это автоматически добавляет перечисленные имена в роль.

CREATE ROLE finance WITH NOLOGIN;
                                        Использование CREATE ROLE и GRANT оператор — это предоставляет все разрешения вновь созданной роли для перечисленных имен.
GRANT finance TO charlie;

CREATE ROLE fran WITH LOGIN IN ROLE employees, managers;  Вы также можете добавить пользователей в группы при создании, указав IN ROLE вместе с CREATE ROLE оператором.
------------------------------------------------
Безопасность на уровне схемы и таблицы.    Вы узнали о безопасности на уровне схемы и таблицы и о том, как включение привилегий по умолчанию может упростить 
                                            процесс предоставления разрешений.
                                            PostgreSQL предлагает возможность писать GRANTоператоры, указывающие определенные 
                                            столбцы для набора разрешений, к которым применяется
GRANT SELECT (project_code, project_name, project_status) 
ON projects to employees;

SELECT project_code, project_status      Когда запрос изменяется на следующий, ошибка не выдается, поскольку запрос не запрашивает какие-либо ограниченные столбцы.
FROM projects LIMIT 1
-------------------------------------------------
Безопасность на уровне строк и столбцов. Вы узнали об использовании этих инструментов для более точного контроля над тем, к каким данным в
                                          таблице может получить доступ пользователь.
                                          PostgreSQL имеет функцию, называемую безопасностью на уровне строк (RLS),которая позволяет разработчикам определять 
                                          разрешения для отдельных строк.

CREATE POLICY emp_rls_policy ON accounts FOR SELECT      Создает политику RLS ONв виде таблицы ( accounts) и указывает тип разрешений, к которому применяется политика.
 TO sales USING (salesperson=current_user);              Указывает роль ( sales), к которой применяется эта политика с использованием TO <role name>.
                                                         Указывает условие, которое необходимо проверить перед тем, как разрешить пользователю выполнять действие. 
                                                         В этом примере политика такова, что current_userдолжно равняться значению в salespersonстолбце этой строки.
                                                         Результатом этого утверждения является то, что теперь у нас есть неактивная политика с именем «emp_rls_policy»
 ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;         Далее нам нужно включить RLS для таблицы, на которую ссылается политика.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                           ИНДЕКСЫ

Индексы — это мощные инструменты, которые при правильном использовании могут значительно повысить скорость ваших запросов к базе данных, но при 
          небрежном использовании могут принести больше вреда, чем пользы.

Как увидеть, какие индексы существуют в таблице

    SELECT *
    FROM pg_indexes
    WHERE tablename = '<table_name>';

 может быть мощным инструментом для просмотра того, как индекс влияет на ваши запросы.

   EXPLAIN ANALYZE                                

 Как построить индекс

   CREATE INDEX <index_name> ON <table_name> (column_name);

Многостолбцовые индексы позволяют использовать более одного столбца в качестве индекса в таблице.

   CREATE INDEX <index_name> ON <table_name> (<column_name1>, <column_name2>...);

Вы можете сбросить индекс. Это может быть полезно, если вы изменяете большое количество записей в индексированной таблице.

    DROP INDEX IF EXISTS <index_name>;

Чтобы увидеть размер таблицы базы данных, вы можете запустить скрипт

   SELECT pg_size_pretty (pg_total_relation_size('<table_name>'));

Некоторые преимущества и недостатки индексов:
Увеличение скорости поиска/фильтрации
Увеличение места для хранения
Увеличение времени выполнения для вставки/обновления/удаления затронутых индексов.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                             ПРОМЕЖУТОЧНЫЕ ИНДЕКСЫ
Частичный индекс
Частичный индекс позволяет индексировать подмножество таблицы, позволяя выполнять поиск только по этой группе записей в таблице.
Если мы знаем, что все внутренние сотрудники имеют email_addressокончание на '@wellsfargo.com', мы запишем частичный индекс следующим образом:

CREATE INDEX users_user_name_internal_idx ON users (user_name)
WHERE email_address LIKE '%@wellsfargo.com';
----------------------------------------
Сортировать по    Чтобы указать порядок индекса, вы можете добавить порядок, в котором вы хотите, чтобы ваш индекс сортировался при создании индекса
                  Если бы вы регулярно выполняли этот запрос, вы могли бы повысить скорость, создав свой индекс следующим образом:

CREATE INDEX logins_date_time_idx ON logins (date_time DESC, user_name);
-----------------------------------------
Первичные ключи и индексы   PostgreSQL автоматически создает уникальный индекс для любого первичного ключа в ваших таблицах.
                            Уникальный индекс, первичный ключ и уникальное ограничение отклоняют любую попытку иметь в таблице две записи с одинаковым значением

ALTER TABLE customers ADD PRIMARY KEY (customer_id);
---------------------------------------
Кластерный индекс     Таблица может иметь множество индексов. Чтобы расширить это, все индексы являются либо кластеризованными индексами, 
                      либо некластеризованными индексами.  Кластерный индекс часто привязан к первичному ключу таблицы.
                      Когда для таблицы создается кластеризованный индекс, данные физически организуются в структуре таблицы, чтобы сократить время поиска. 
                      Для кластеризации таблицы базы данных с использованием существующего индекса (скажем products_product_name_idx)
                       в productsтаблице вы должны использовать:

 CLUSTER products USING products_product_name_idx;
      
                     Если вы уже установили, какой индекс должен быть кластеризован, вы можете просто указать системе, к какой таблице применить кластер.

  CLUSTER products;  
                     имеет определенный индекс для использования, вы можете просто вызвать  CLUSTER;
--------------------------------------------------
Некластеризованные индексы           содержат записи столбцов, которые они индексируют, и указатель на фактические данные в таблице

CREATE INDEX customers_state_name_idx ON customers(state_name);

SELECT last_name, state_name
FROM customers
WHERE state_name = 'Texas'
ORDER BY last_name;
------------------------------------------
Сканирование только индекса             Поиск, выполняемый некластеризованным индексом в таблице после нахождения записей, имеет свою стоимость

CREATE INDEX customers_idx ON customers (last_name, first_name);
----------------------------------------------
Объединение индексов       Одиночный многостолбцовый индекс быстрее (при правильном упорядочении), чем сервер, объединяющий индексы.          
                           Индекс с несколькими столбцами менее эффективен, чем одиночный индекс, в тех случаях, когда необходим одиночный индекс.  
                           Вы можете создать их все (два одиночных индекса и один многоколоночный индекс), и тогда сервер будет пытаться использовать лучший в каждом 
                           случае, но если они все не используются относительно часто/одинаково, то это неправильное использование индексов.

EXPLAIN ANALYZE SELECT *
FROM customers
WHERE last_name = 'Jones'
  AND first_name = 'Steve';
CREATE INDEX customers_last_name_first_name_idx ON customers (last_name, first_name);

EXPLAIN ANALYZE SELECT *
FROM customers
WHERE last_name = 'Jones'
  AND first_name = 'Steve';
-----------------------------------------------------------
Индексы на основе выражений   Например, если вы хотите обеспечить уникальность company_nameв manufacturesтаблице, 
                              вы можете добавить UNIQUE параметр, чтобы сделать уникальное ограничение индекса для результатов вашего индекса.
                              Другими словами, при создании индекса UNIQUEсистема автоматически создаст ограничение, соответствующее логике индекса
                              PostgreSQL, когда для таблицы создается первичный ключ, сервер базы данных автоматически создает уникальный индекс для этой таблицы.


CREATE UNIQUE INDEX customers_email_address_lower_unique_idx ON customers(LOWER(email_address));
INSERT INTO customers (first_name, last_name, email_address)
VALUES ('John', 'Doe', 'ExaMPle@SampLE.COM'),
('Jane','Doe','example@sample.com');

Индексы — очень мощные инструменты, и у вас, как у инженера баз данных, есть множество вариантов их реализации
------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                 ОБСЛУЖИВАНИЕ БАЗЫ ДАННЫХ POSTGRESQL
Как UPDATEили DELETEсоздает мертвые кортежи на диске.

Понимание того, когда VACUUM, VACUUM ANALYZE, или VACUUM FULL. Каждую из них можно использовать для более эффективн использования пространства базы данных, когда это необходимо.

VACUUMпросто помечает мертвые кортежи и позволяет повторно использовать это пространство будущими обновлениями.
 
             VACUUM mocked_data.time_series;    

VACUUM ANALYZEвыполняет VACUUM, но также обновляет внутреннюю статистику PostgreSQL и может способствовать дальнейшему повышению производительности запросов после большого UPDATE.
             ANALYZE schema.table;
     
VACUUM FULLявляется наиболее агрессивной VACUUM стратегией, она может полностью очистить таблицу от мертвых кортежей и вернуть место на диск. Однако его следует использовать 
с осторожностью, поскольку он может помешать другим пользователям запрашивать таблицу.

           VACUUM FULL rand;

Осведомленность о autovacuum процессе, который автоматически запускает периодические VACCUUMs для обеспечения эффективного использования диска таблицами базы данных.

Возможность интерпретировать данные из pg_stat_all_tables. Это очень удобный стол. Возможность ссылаться на него, чтобы понять использование диска, частоту 
очистки или количество мертвых кортежей, позволит вам диагностировать широкий спектр проблем с производительностью базы данных.
                                     
                DELETE * FROM rand WHERE true;
                VACUUM FULL rand;

Понимание того, когда TRUNCATE можно использовать вместо более дорогих альтернатив.TRUNCATE можно использовать только для очистки всех строк из таблицы

                   TRUNCATE mock.current_day_logins;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                       КАК РАБОТАЮТ КОМПЬЮТЕРЫ

Входные данные — это данные, которые мы передаем нашим компьютерам.
Обработка состоит из перевода ввода и инструкций, данных для вывода.
Память используется для хранения временной или постоянной информации.
Вывод — это информация, которую возвращает компьютер.
Теперь, когда у нас есть общее представление о том, как работает.

ециалисты по информатике, понимаем как примеры двоичных файлов, можно разделить на две отдельные категории:
                                                                                                                                  1 | 1
Двоичные числа                                                                                                                    2 | 10                            
Двоичные данные                                                                                                                   3 | 11                    
      Общие примеры двоичных данных включают в себя:                                                                              4 | 100
                                                                                                                                  5 | 101
Машинный код ( 001010101100111001010010011)                                                                                       6 | 110
Логические выражения ( Trueили False)                                                                                             7 | 111
Аппаратные состояния ( Onили Off)                                                                                                 8 | 1000
Сеть и хранилище файлов                                                                                                           9 | 1001
                                                                                                                                 10 | 1010
Двоичные данные также обычно имеют определенную длину, например, восемь битов называются байтами , а два байта (16 битов) называются словом

В двоичном формате крайняя правая цифра называется наименее значащим битом (LSB), а крайняя левая цифра называется наиболее значащим битом (MSB).
нечетные числа в двоичном коде заканчиваются на 1, а все четные числа заканчиваются на 0. 

В десятичной форме это уравнение 4 * 7 = 28. В двоичном виде 28 = 11100.

Дивиденд 10	Делитель 10	Результат 10	Остаток 10	Совокупный двоичный файл 2
27 (нечетное)	2	13	1 -> младший бит	1
13 (нечетное)	2	6	1	11
6 (четное)	2	3	0	011
3 (нечетное)	2	1	1	1011
1 (нечетный)	2	0	1 -> старший бит	11011

     **Ответ: 27(10) = 11011(2)

Десятичная дробь	Бинарный                               1100100 - 101 = 1011111
0 + 1 = 1	0 + 1 = 1                                      1100100 / 101 = 10100
1 + 1 = 2	1 + 1 = 10                                      100 * 111 = 11100
2 + 1 = 3	10 + 1 = 11                                     10 + 11 = 101
3 + 1 = 4	11 + 1 = 100


Добавляем 101101(2) и 111(2) :v                                                               Двоичные числа	Результат
                                                                                                 0 / 1            0
Binary  | Decimal                                                                                1 / 1            1
  1111  |  1    <- carried digits                                                                0 / 1         неопределенный
 101101 |  45                                                                                    1 / 0         неопределенный
+   111 | + 7
------- | ---
 110100 |  52

Десятичная дробь	Бинарный                                                             Двоичные числа	Результат
8 - 1 = 7	1000 - 1 = 111                                 1 - 0 = 1                          0 * 0              0
7 - 1 = 6	111 - 1 = 110                                  10 - 1 = 1                         0 * 1              0
6 - 1 = 5	110 - 1 = 101                                  11 - 1 = 10                        1 * 0              0
5 - 1 = 4	101 - 1 = 100                                                                     1 * 1              1

Двоичная система счисления по основанию 2
Двоичные числа представлены цифрами 0и 1. Это можно выразить как:
0/1
off/on
true/false
или множество других бинарных терминов
Каждая двоичная цифра называется битом.
Двоичные числа могут быть преобразованы в и из других систем счисления, таких как десятичная.
Двоичные числа можно складывать, вычитать, умножать и делить почти так же, как и десятичные числа.
Крайняя левая цифра в двоичном числе называется старшим значащим битом (MSB), а самая правая — наименее значащей цифрой (LSB).

--------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                      Введение в ИСА
ISA, или архитектура набора инструкций, — это структура, определяющая связь между аппаратным и программным обеспечением наших компьютеров.
Это набор команд, которые могут выполнять наши компьютеры, и эти определения относятся к двум различным методам проектирования: CISC и RISC.
       возникли три основных ISA:

x86 (дизайн CISC)
ARM (RISC-дизайн)
MIPS (модифицированный дизайн RISC для встроенных процессоров)

Архитектура набора инструкций , или ISA, действует как переводчик между нашим оборудованием и программным обеспечением.

Наш главный набор — это программы, с которыми мы взаимодействуем каждый день, например веб-браузер, в котором вы сейчас проходите этот курс.

Эти программы написаны на языках следующего уровня, таких как Java или Python.

Компилятор берет эти языки и с помощью языка ассемблера переводит этот код в двоичный.

Двоичный код, также известный как машинный код, соответствует архитектуре набора инструкций.

Нижняя булочка — это фактическое аппаратное обеспечение компьютера, ЦП, память и другие компоненты, которые будут манипулировать 
данными на основе машинного кода, который мы ему даем.
                  
                                                                                   Инструкции MIPS

----------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                    ЯЗЫК АССЕМБЛЕРА

Ассемблер — это низкоуровневый язык программирования, используемый для прямого преобразования инструкций в машинный код компьютера в более удобном для человека виде. 

Встроенные системы с ограниченным объемом памяти и оборудования
Прямое аппаратное тестирование
Оптимизация программного обеспечения

есть четыре шага, известные как процесс компиляции, которые составляют путь, который проходит высокоуровневый код до достижения аппаратного обеспечения:
Предварительная обработка — это первый шаг компиляции,используется для подготовки пользовательского кода к машинному коду путем удаления комментариев
Компиляция — это процесс извлечения расширенного файла из препроцессора и перевода программы на оптимизированный язык ассемблера.
Ассемблирование — это процесс использования программы на ассемблере и использования ассемблера для генерации машинного кода.
Связывание — это процесс заполнения вызовов функций, включая дополнительные объекты, библиотеки и исходный код из других мест.

                   Вот некоторые из основных типов операций, составляющих программу сборки:

Арифметика (сложение/вычитание)
Доступ к памяти (загрузка/сохранение)
Поток управления (ветвь/прыжок)
---------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                 КЭШ
Краткое содержание
Хорошая работа, доходящая до конца этого урока! Вот краткое изложение тем, которые мы рассмотрели:

Включение кэш-памяти в иерархию памяти помогает сократить разрыв в производительности процессора и памяти.
Копии данных хранятся в кэш-памяти, чтобы предоставить процессору более быстрый доступ к данным по сравнению с основной памятью.
Попадание в кеш — это когда запрошенные данные находятся в кеше.
Кэш-промах — это когда запрошенные данные не находятся в кеше, и данные должны быть извлечены из основной памяти.
Политика замены кеша определяет, какая запись в кеше будет заменена новыми данными.
Ассоциативность кэша назначает ячейки основной памяти указанным записям кэша.
Политика записи в кэш определяет, как данные записываются обратно вниз по иерархии памяти.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                         КОНВЕЙЕРИЗАЦИЯ ИНСТРУКЦИЙ
Давайте пройдемся по тому, что мы узнали о:

Конвейерная обработка инструкций — это метод, который позволяет одному компьютерному процессору разбивать и обрабатывать несколько инструкций одновременно.
Аппаратное обеспечение процессора предназначено для увеличения пропускной способности наборов инструкций.
Обработку инструкции можно разбить на пять шагов:
Получить инструкцию
Инструкция декодирования
Выполнять
Доступ к памяти
Обратная запись реестра
Стоимость производства и требуемая мощность увеличиваются по мере увеличения сложности процессора.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                          Суперскалярная архитектура
Процессоры, использующие преимущества суперскалярной архитектуры, предназначены  для использования методологии параллелизма,
когда инструкции отправляются в разные исполнительные блоки одновременно,что позволяет обрабатывать более одной инструкции за один такт.
Супермасштабирование имеет несколько ограничений

Уровень параллелизма в наборе инструкций, с которым он работает.
Стоимость проверки зависимостей. Сколько накладных расходов необходимо
Проверка инструкции ветки. Сколько стоит обследование каждого из филиалов

Суперскаляр — это метод, который разделяет инструкции на несколько исполнительных блоков.
Суперскаляр отличается от конвейерной обработки, потому что конвейерная обработка запускает инструкции, чтобы попытаться заполнить каждый шаг процесса в 
    каждом цикле, суперскалярная использует несколько исполнительных единиц для увеличения пропускной способности.
Суперскаляр отличается от многоядерных процессоров тем, что у суперскаляра есть несколько ALU, тогда как у многоядерного есть несколько целых процессоров.
Опасности, связанные с суперскаляром, включают опасности данных, опасности управления и структурные опасности.
Из-за повышенной сложности суперскаляра существуют практические ограничения его эффективности.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                    ПАРАЛЛЕЛИЗМ НА УРОВНЕ ДАННЫХ

                                                                            SIMD
 SIMD — это один из подходов к параллелизму на уровне данных, и он почти так же стар, как современная компьютерная эра.
Различные приложения SIMD:

Векторная обработка
SIMD-расширения
Графические процессоры (GPU)

SIMD-архитектуры и их преимущества в приложениях с большим объемом данных.
Векторные процессоры и их раннее влияние на архитектуру SIMD.
Элементы векторной архитектуры, такие как векторные регистры, дорожки и внутренние циклы.
Расширения SIMD и то, как векторные процессоры повлияли на их реализацию коммерческой обработки.
Графические процессоры и то, как они используют другой подход к архитектуре SIMD.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
from Node import Node
from help import test_your_code
class DoublyLinkedList:
  def __init__(self, value):
     # create new Node with value
    new_node = Node(value)

    # create instance variable head_node to point to new_node
    self.head_node = new_node

    # create instance variable tail_node to poiint to new_node
    self.tail_node = new_node


_____________________________________________________________________________________________________________________________________
                                                       dersdi
      Как setInterval()считается асинхронный код?


     setInterval()считается асинхронным кодом, потому что предоставленная функция обратного
      вызова не блокируется другим кодом — функция обратного вызова может
     выполняться параллельно с другим исполняемым кодом. 
     Определяющий фактор для выполнения функции обратного вызова 
      определяется вторым предоставленным аргументом.
___________________________________________________________________________________________________________________________________


создавать и отображать элементы JSX! Это первый шаг к свободному владению React.

import React from 'react';
import ReactDOM from 'react-dom';                                        b g v d a


ReactDOM.render(<h1>Render me!</h1>, document.getElementById('app'));

---------------------------------------------------------------------------------------------------
const greatestDivEver = <div>i am div</div>;  bunu bele yazmag olar

    const greatestDivEver = React.createElement(
  'div',
  null,
  'i am div'
   
);
__________________________________________________________________________________________________________________________
                                                              dersdi
    import React from 'react';
    import ReactDOM from 'react-dom';

    class MyComponentClass extends React.Component {
      render() {
      return <h1>Hello world</h1>;
     }
    }
    ReactDOM.render(
    <MyComponentClass />,
    document.getElementById('app')
    );
   
    <MyComponentClass />
_________________________________________________________________________________________
                                                            dersdi
         def add_two(my_input):
           return my_input + 2
    
         Эту же функцию можно записать как лямбда-функцию:

          add_two = lambda my_input: my_input + 2
           
           print(add_two(3))                       -----------> 5 olacag

________________________________________________________________________________________________________________________________________________________________
      Следующие команды полезны в рабочем процессе ветки Git.

git branch: список всех ветвей проекта Git.
git branch branch_name: Создает новую ветку.
git checkout branch_name: Используется для переключения с одной ветки на другую.
git merge branch_name: Используется для объединения изменений файлов из одной ветки в другую.
git branch -d branch_name: Удаляет указанную ветвь.

-----------------------------------------------------------------------------------------------------------------------------------------------------------
 
 Удаленный — это репозиторий Git, который находится за пределами папки вашего проекта Git . 
Пульты могут жить в Интернете, в общей сети или даже в отдельной папке на вашем локальном компьютере.

Git Collaborative Workflow — это шаги, которые обеспечивают плавную разработку проекта, 
когда несколько соавторов работают над одним и тем же проектом Git.

Мы также изучили следующие команды

git clone: Создает локальную копию удаленного.
git remote -v: список пультов проекта Git.
git fetch: извлекает работу с удаленного компьютера в локальную копию.
git merge origin/master: Сливается origin/masterс вашей локальной веткой.
git push origin <branch_name>: отправляет локальную ветку на originудаленную.
--------------------------------------------------------------------------------------------------------------------------------------------------

Найдите все предметы с нечетной ценой и добавьте название предмета в discounted_items список.
Убедитесь, что код тестирования, который печатается, discounted_items находится внизу вашего кода. НЕ распечатывайте товары, на которые нет скидки.

Напомним : четные числа делятся на 2, а нечетные числа не делятся на 2.


# All of our store items
all_items = [["Taffy", 1], ["Chocolate", 2], ["Cup", 5], ["Plate", 10], ["Bowl", 11], ["Silverware", 22]]

# Empty discounted_items list

discounted_items = []
for items, end in all_items:
  if end % 2 == 1:
    discounted_items.append(items)                                         <------bunu tapdig
print(discounted_items)

# Your code here

# For testing purposes: print discounted list
print(discounted_items)
-----------------------------------------------------------------------------------------------------------------------------------------------------

Используйте while цикл в своей функции, чтобы вычислить, сколько лакомств для собак вы можете купить.
return общее количество лакомств для собак, которые вы смогли купить ( num_bought).
Убедитесь, что помеченный тестовый код находится внизу вашего кода. Должен быть:

total_1 = buy_items(100, 10, 4)
print("Test 1: " + str(total_1))
total_2 = buy_items(10, 10, 4)
print("Test 2: " + str(total_2))
Примечание. Если вы создаете бесконечный цикл, обновите страницу, чтобы повторить попытку.

starting_money = 100
starting_num_items = 10
item_price = 4

# Your code here
def buy_items():                                     <------starting_money, starting_num_items, items_price     
  num_bought = 0
  
  return 0


  while starting_num_items > 0 and starting_money - item_price > 0:
     starting_money =  starting_money - items_price
     starting_num_items -= 1
     num_bought += 1

  return num_bought

-----------------------------------------------------------------------------------------------------------------------------------------------------
Вы только что написали программу для своего последнего проекта, и теперь вам нужно зафиксировать проект в новом репозитории GitHub. Убедись в:

Запустите свою программу Python 3, чтобы протестировать ее. Ваша программа называется startup.py.
Инициализируйте git и добавьте его startup.py в тестовую область.
Совершить startup.py. Включите сообщение фиксации в команду терминала.
Не используйте clear для очистки терминала. Перед проверкой своей работы убедитесь, что ваши команды видны в Терминале.
  

python3 startup.py
git init
git add startup.py
git status
git commit -m "Complete first new file"
git log
-----------------------------------------------------------------------------------------------------------------------------------------------------------


Ваша задача состоит только в том, чтобы взять поля Name и Phone Number и распечатать каждую строку как:

import csv

with open('employees.csv', newline='') as users_csv:
  
  address_reader = csv.DictReader(users_csv)
  for row in address_reader:
  
    print(row['Name'], ':', row['Phone Number'])

----------------------------------------------------------------------------------------------------------------------------------------------

  Завершите Queue()класс, реализуя остальную часть .enqueue()метода. Метод .enqueue()должен добавить узел к Queue экземпляру, сохраняя при этом файлы size

from node import Node

class Queue:
  def __init__(self,  ?  ):        ----max_size=None
    self.head = None
    self.tail = None
    self.size = 0
    -------------                    self.max_size = max_size
  def enqueue(self, value):
  ----------------------------------------------------------------------------------------------------------------------------------
       if self.has_space():
      item_to_add = Node(value)
      print("Adding " + str(item_to_add.get_value()) + " to the queue!")
      if self.is_empty():
        self.head = item_to_add
        self.tail = item_to_add
      else:
        self.tail.set_next_node(item_to_add)
        self.tail = item_to_add
      self.size += 1
    else:
      print("Sorry, no more room!")
-------------------------------------------------------------------------------------------------------------------------------------------------------
  middle_index = len(unsorted) // 2
  left_split = unsorted[:middle_index]
  right_split = unsorted[middle_index:]

  l_sorted = merge_sort(left_split)
  r_sorted = merge_sort(right_split)
  # Complete the code below
------------------------------------------------------                    hazirdi
 
  return merge(l_sorted, r_sorted)
  

-----------------------------------------------------------------------------------------------------------------------------------------------------

Приведенный ниже код представляет собой незавершенную реализацию алгоритма быстрой сортировки. Алгоритм использует опорный элемент для разделения 
списка на элементы меньше опорного элемента и больше опорного элемента.


      list[i], list[less_than_ptr] = list[less_than_ptr], list[i]                 hazirdu
      less_than_ptr += 1
      
  list[end], list[less_than_ptr] = list[less_than_ptr], list[end]
  -----------------------------------------------------
  quicksort(list, start, less_than_ptr - 1)
  quicksort(list, less_than_ptr + 1, end)
-------------------------------------------------------

l = [4,8,2,5,1,9,0,7,3,6]
quicksort(l, 0, 9)
print(l)
----------------------------------------------------------------------------------------------------------------------------------------------------
Требуется найти в массиве list_1 самый близкий по величине элемент к заданному числу k и вывести его.

Пример:


list_1 = [1, 2, 3, 4, 5]
k = 6
# 5

count = list_1[0] 
for i in list_1:
        if abs(i - k) < abs(count - k):
            count = i
            count
count = list_1[0] 
for i in list_1:
        if abs(i - k) < abs(count - k):
            count = i
print(count)
----------------------------------------------------------------------------------------
# В настольной игре Скрабл (Scrabble) каждая буква имеет определенную ценность.
# В случае с английским алфавитом очки распределяются так:

eng = 'qwertyuiopasdfghjklzxcvbnm'
#
rus = 'йцукенгшщзхъфывапролджэячсмитьбюё'
#
list_English = {1:'AEIOULNSTR', 2:'DG', 3:'BCMP',
                4:'FHVWY', 5:"K" , 8:'JX', 10:'QZ'}
list_Russian = {1:'АВЕИНОРСТ', 2:'ДКЛМПУ', 3:'БГЁЬЯ',
                4:'ЙЫ', 5:'ЖЗХЦЧ', 8:'ШЭЮ', 10:'ФШЪ'}
# Пример:
#k = 'laptop'
k = 'ящерица'
#22
#k = 'lizard'

#k = 'ноутбук'
# 12

if k[0].lower() in eng:
        summa = 0
        for letter in k:
         for key, value in list_English.items():
             if letter.upper() in value:
                 summa += key
        print(summa)
else:
    if k[0].lower() in rus:
         summa = 0
         for letter in k:

             for key, value in list_Russian.items():
                 if letter.upper() in value:
                     summa += key
    print(summa)
---------------------------------------------------------------
В среде разработки с помощью команды python -m venv .venv создадим папку с окружением .venv.

Если окружение не активировалось автоматически, можно сделать это вручную, прописав путь к файлу активации в формате source .venv/bin/activate, 
где source — команда языка программирования Bash.



import time
import logging
import asyncio

from aiogram import Bot, Dispatcher, executor, types

TOKEN = "здесьбудетваштокенот@BotFather"
MSG = "Программировал ли ты сегодня, {}?"

logging.basicConfig(level=logging.INFO)

bot = Bot(token=TOKEN)
dp = Dispatcher(bot=bot)

@dp.message_handler(commands=["start"])
async def start_handler(message: types.Message):
    user_id = message.from_user.id
    user_name = message.from_user.first_name
    user_full_name = message.from_user.full_name
    logging.info(f'{user_id} {user_full_name} {time.asctime()}')
    await message.reply(f"Привет, {user_full_name}!")

    for i in range(7):
        await asyncio.sleep(60*60*24)
        await bot.send_message(user_id, MSG.format(user_name))

if __name__ == "__main__":
    executor.start_polling(dp)
-----------------------------------------------------------------------------------------------------------
    Конечно, вот полный код для создания спортивного логотипа в Django:

1. Создайте новый проект Django с помощью команды: `django-admin startproject sports_logo_project`

2. В `sports_logo_project/settings.py`, добавьте в список `INSTALLED_APPS` ваше приложение `logo`:
```python
INSTALLED_APPS = [
    ...
    'logo',
]
```

3. В `sports_logo_project/urls.py`, добавьте маршрут для вашего приложения `logo`:
```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('logo/', include('logo.urls')),
]
```

4. Создайте новое приложение Django с помощью команды: `python manage.py startapp logo`

5. В `logo/models.py`, создайте модель `Logo`, которая будет представлять спортивный логотип:
```python
from django.db import models

class Logo(models.Model):
    image = models.ImageField(upload_to='logos/')
```

6. Создайте миграции для модели `Logo` с помощью команды: `python manage.py makemigrations`

7. Примените миграции с помощью команды: `python manage.py migrate`

8. В `logo/forms.py`, создайте форму `LogoForm`, которая позволит пользователям загрузить логотип:
```python
from django import forms
from .models import Logo

class LogoForm(forms.ModelForm):
    class Meta:
        model = Logo
        fields = ['image']
```

9. В `logo/views.py`, создайте представление `create_logo`, которое будет отображать форму для загрузки логотипа:
```python
from django.shortcuts import render
from .forms import LogoForm

def create_logo(request):
    if request.method == 'POST':
        form = LogoForm(request.POST, request.FILES)
        if form.is_valid():
            form.save()
            return render(request, 'logo/success.html')
    else:
        form = LogoForm()
    
    return render(request, 'logo/create.html', {'form': form})
```

10. В `logo/urls.py`, добавьте маршрут для представления `create_logo`:
```python
from django.urls import path
from . import views

urlpatterns = [
    path('create/', views.create_logo, name='create_logo'),
]
```

11. Создайте папку `templates` в папке вашего приложения `logo`. Затем создайте два HTML-шаблона: `create.html` и `success.html`.

`create.html` будет отображать форму для загрузки логотипа:
```html
<!DOCTYPE html>
<html>
<head>
    <title>Create Logo</title>
</head>
<body>
    <h1>Create Logo</h1>

    <form method="post" enctype="multipart/form-data">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Create</button>
    </form>
</body>
</html>
```

`success.html` будет отображать сообщение об успешной загрузке логотипа:
```html
<!DOCTYPE html>
<html>
<head>
    <title>Success</title>
</head>
<body>
    <h1>Logo created successfully!</h1>
</body>
</html>
```

Теперь вы можете запустить сервер Django и перейти по адресу `http://localhost:8000/logo/create/`, чтобы увидеть форму для загрузки спортивного логотипа.

Обратите внимание, что для загрузки изображений в Django, вам нужно установить и настроить модуль хранения статических файлов, такой как Amazon S3 или использовать локальное хранение вместо `MEDIA_ROOT` и `MEDIA_URL` в настройках вашего проекта Django.


-------------------------------------------------------------------------------------------


   Ваш запрос слишком обширен, чтобы написать весь код для спортивного сайта. Однако я могу предложить вам пример базовой структуры проекта на Django, которую вы можете использовать в своем спортивном сайте. Вот некоторые ключевые файлы и каталоги:

1. Создайте новый Django проект:
```
$ django-admin startproject sports_site
```

2. Зайти в созданную директорию проекта:
```
$ cd sports_site
```

3. Создайте новое Django приложение:
```
$ python manage.py startapp sports_app
```

4. Откройте файл `settings.py` в директории `sports_site` и добавьте `'sports_app'` в список `INSTALLED_APPS`:
```python
INSTALLED_APPS = [
    ...
    'sports_app',
]
```

5. В директории `sports_app` создайте файл `models.py` и определите модели для вашего спортивного сайта:
```python
from django.db import models

class Team(models.Model):
    name = models.CharField(max_length=100)
    sport = models.CharField(max_length=100)
    # Добавьте другие поля

class Player(models.Model):
    name = models.CharField(max_length=100)
    team = models.ForeignKey(Team, on_delete=models.CASCADE)
    # Добавьте другие поля

class Game(models.Model):
    team1 = models.ForeignKey(Team, on_delete=models.CASCADE, related_name='games_as_team1')
    team2 = models.ForeignKey(Team, on_delete=models.CASCADE, related_name='games_as_team2')
    date = models.DateTimeField()
    # Добавьте другие поля
```

6. Создайте и примените миграции, чтобы создать таблицы для ваших моделей:
```
$ python manage.py makemigrations
$ python manage.py migrate
```

7. Откройте файл `urls.py` в директории `sports_site` и добавьте пути к вашим представлениям:
```python
from django.urls import path

from sports_app import views

urlpatterns = [
    path('teams/', views.TeamsView.as_view(), name='teams'),
    path('players/', views.PlayersView.as_view(), name='players'),
    path('games/', views.GamesView.as_view(), name='games'),
]
```

8. В директории `sports_app` создайте файл `views.py` и определите представления для ваших страниц:
```python
from django.views.generic import ListView
from .models import Team, Player, Game

class TeamsView(ListView):
    model = Team
    template_name = 'teams.html'
    context_object_name = 'teams'

class PlayersView(ListView):
    model = Player
    template_name = 'players.html'
    context_object_name = 'players'

class GamesView(ListView):
    model = Game
    template_name = 'games.html'
    context_object_name = 'games'
```

9. Создайте шаблоны HTML в директории `templates` для каждой страницы вашего сайта (`teams.html`, `players.html`, `games.html`). Пример шаблона для `teams.html`:
```html
<ul>
  {% for team in teams %}
    <li>{{ team.name }} - {{ team.sport }}</li>
  {% endfor %}
</ul>
```

10. Запустите веб-сервер Django:
```
$ python manage.py runserver
```

Это базовая структура проекта на Django для спортивного сайта. Вам нужно будет доработать код и добавить функциональность в зависимости от ваших потребностей.
---------------------------------------------------------------------------------
      animasiya aid saytlar

    https://www.reddit.com/r/Python/comments/10g5nay/use_python_to_build_a_free_stable_diffusion_app/?onboarding_redirect=%2Fr%2FPython%2Fcomments%2F10g5nay%2Fuse_python_to_build_a_free_stable_diffusion_app%2F

     https://www.assemblyai.com/blog/build-a-free-stable-diffusion-app-with-a-gpu-backend/

     https://colab.research.google.com/drive/19r-7IaJEZHKtbW82XJwKlOu64-KRMBp5?usp=sharing&ref=assemblyai.com#scrollTo=Or8tIBlmVFbv

-----------------------------------------------------------------------------------------------------------------------
frilans  saytlar:
    https://fourerr.com/how-it-works/
  
  https://medium.com/@QUBAASHRAFBALOCH/101-websites-to-earn-money-4a7783ff5f90

----------------------------------------------------------------------------------------------------------------------------

И так, рассмотрим первый этап парсинга — Поиск данных.

Так как нужно парсить что-то полезное и интересное давайте попробуем спарсить информацию с сайта work.ua.


pip install beautifulsoup4

pip install requests
pip install pandas

import requests
from bs4 import BeautifulSoup as bs
import pandas as pd

URL_TEMPLATE = "https://www.work.ua/ru/jobs-odesa/?page=2"
FILE_NAME = "test.csv"


def parse(url = URL_TEMPLATE):
    result_list = {'href': [], 'title': [], 'about': []}
    r = requests.get(url)
    soup = bs(r.text, "html.parser")
    vacancies_names = soup.find_all('h2', class_='add-bottom-sm')
    vacancies_info = soup.find_all('p', class_='overflow')
    for name in vacancies_names:
        result_list['href'].append('https://www.work.ua'+name.a['href'])
        result_list['title'].append(name.a['title'])
    for info in vacancies_info:
        result_list['about'].append(info.text)
    return result_list


df = pd.DataFrame(data=parse())
df.to_csv(FILE_NAME)

------------------------------------------------------------------------------------------------------
instagrami aid 

https://machinelearningmastery.ru/increase-your-instagram-followers-with-a-simple-python-bot-fde048dce20d/
--------------------------------------------------------
import ffmpeg


def video_to_gif():
    stream = ffmpeg.input("video_0.mp4")
    stream = ffmpeg.output(stream, "video_0.gif")
    ffmpeg.run(stream)


def main():
     video_to_gif()


if __name__ == "__main__":
     main()
------------------------------------------------------------
def get_file_info(file_path):
    file_name = file_path.split("/")[-1]
    file_extension = file_name.split(".")[-1]
    path = file_path[:-len(file_name)]
    return (path, file_name[:-len(file_extension)-1], "." + file_extension)
---------------------------------------------------
Avtotest

Добавьте в пакет, созданный на семинаре шахматный модуль.
Внутри него напишите код, решающий задачу о 8 ферзях, включающий в себя
функцию is_attacking(q1,q2), проверяющую, бьют ли ферзи друг друга и heck_queens(queens), которая проверяет все возможные пары ферзей.
Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. Вам дана расстановка 8 ферзей на доске, определите, есть ли среди них пара бьющих друг друга.
Программа получает на вход восемь пар чисел, каждое число от 1 до 8 - координаты 8 ферзей. Если ферзи не бьют друг друга верните истину, а если бьют - ложь. Не забудьте напечатать результат  

from itertools import combinations

def is_attacking(q1, q2):
    # Проверяем, бьют ли ферзи друг друга
    return q1[0] == q2[0] or q1[1] == q2[1] or abs(q1[0] - q2[0]) == abs(q1[1] - q2[1])

def check_queens(queens):
    # Проверяем все возможные пары ферзей
    for q1, q2 in combinations(queens, 2):
        if is_attacking(q1, q2):
            return False
    return True
_______________________________________________________-------

  seh 119 da goyulur
                           <div class="carousel-item"><img class="w-100 d-block w-100" src="./img/3.png" alt="перетяжка дивана"></div>
                            <div class="carousel-item"><img class="w-100 d-block w-100" src="./img/2.png" alt="замена обивки дивана"></div>
                            <div class="carousel-item"><img class="w-100 d-block w-100" src="./img/4.png" alt="ремонт и реставрация дивана"></div>



-----------------------------------------------------------
HTTrack — старый интерфейс из нулевых, но свою задачу выполняет полностью. Бесплатный и надёжный, работает везде. 
Getleft — мультиплатформенный граббер, который пытается выкачивать всё, до чего дотянется, включая PHP-скрипты. 
Cyotek WebCopy — для тех, кто любит только Windows, тоже бесплатный.

------------------------------------
.main-header{
	background:url('../img/5555.png') no-repeat;
	background-size:cover;
	width: 100%;
	
}



    https://t.me/+tzDoS_yn439iNmE5




        
-----------------------------------------------------------------------------------------------------
        PS C:\Users\user\Downloads\dev_env\app1> py -Xutf8 manage.py dumpdata goods.Categories -o fixtures/goods/products.json
----------------------------------------------------
proxies.txt

user:pass:host:port
user2:pass:host:port
user3:pass:host:port
-------------------------
185.43.188.127
-----------------------------------------------

wrfakaal:yz5t53xoyceu:38.154.227.167:5868
wrfakaal:yz5t53xoyceu:185.199.229.156:7492
wrfakaal:yz5t53xoyceu:185.199.228.220:7300
wrfakaal:yz5t53xoyceu:185.199.231.45:8382
wrfakaal:yz5t53xoyceu:188.74.210.207:6286
wrfakaal:yz5t53xoyceu:188.74.183.10:8279
wrfakaal:yz5t53xoyceu:188.74.210.21:6100
wrfakaal:yz5t53xoyceu:45.155.68.129:8133
wrfakaal:yz5t53xoyceu:154.95.36.199:6893
wrfakaal:yz5t53xoyceu:45.94.47.66:8110
--------------------------------------------------------------------------------------------------